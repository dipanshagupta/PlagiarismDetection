Fullname,,,,,,,,,,,,,,,,,,,,,,,,,,"Abdul Kotyad, Munawira","The sorting problem could be simplified by using the actual types of arguments to decide which method to execute, since in Java datatype check is performed at runtime and thus the compiler will know which method to execute for which object. Otherwise it will throw a compile error.","While writing a program, the preconditions should be made as weak as possible and the postconditions should be made as strong as possible.This is because a weak precondition will satisfy the values of preconditions which are stronger than itself.And the values of a strong postcondition will satisfy weaker postconditions.",Data migrate.,Principle of Least Astonishment,Yo-Yo effect,Liskov Substitution Principle,The name of the function is ambiguous and it does not mention what the parameters to be passed are and what will be the return parameter.,This could cause a compile time error if the user passes a parameter that is not handled within the function. For ex: square,Separate functions should be written for each functionality with meaningful names. for example:circle getCircle(Shape inshape),"Yes we could still rewrite the code to follow style guidelines, since within the functions the system defined classes are only called and not modified. Only the interface of these classes are used.",PortfolioRecordStockPosition,dividend: This is not a key abstraction as this is just a numerical value.loss: This is not a key abstraction as this can be easily represented as a negative value of gain.,Portfolio/ Position is a whole/part relationship in the system,"gain is the key abstraction that is defined ambiguously , since it is being required to represent short term and long term and also the difference between the current price and the purchase price.gain when used to represent current price - purchase price represents the key abstraction",Bonds is a subclass of portfolio,Responsibility -> CollaboratorremoveStock -> RecordcalculateEarnings-> Record,"class Exam2def method_missing(meth, *args)puts  #{meth} is not definedendende = Exam2.newe.Class_eval dodefine_method :sayHello doputs Hello from sayHelloendende.sayHello",method 1 overrides method 0method 2 overloads method 1,a.eat() gives the following output:Horse eating HayThis is because first the system looks for the eat method in the Animal class. It finds the eat() method(method 0) and then performs dynamic binding to see if a specialized(overridden) form of the same method is present in the subclass Horse. It finds the method eat() (method 1) and calls it.,"No, you cannot prevent both eat methods from being overriden by modifying the Horse class. this can be done by modifying the subclass that derives from the Horse class.","E + merge(O,O) = EO","X + MERGE(AO,BO,CO,ABC)= X + ABCO = XABCO","Z + MERGE(DO,AO) = ZDAO","Q + MERGE(XABCO,YDBEO,ZDAO,XYZ) = QXYZDABCO",The code uses the Strategy Pattern and prints the output based on the value of the variable print_operation at run time.,"The advantage of using this pattern is that , you can choose the algorithm that needs to be implemented based on some value of a parameter. The disadvantage of using this pattern is that, for every new object or parameter value, a new method needs to be implemented. If a method is not implemented , then a error is thrown at run time.""Ambadkar, Aditya",,,,,,,,,,,,,,,,,,,,,,,,,,"Anand Ramchand Bhatia, .",,,,,,,,,,,,,,,,,,,,,,,,,,"Ayyappan, Prathibha","If java used actual types of arguments to decide several methods then in the second iteration, we we send the type is Object, it would decide that the object is a string or an integer and we would not get a compile time error. It would also be able to choose the corresponding the comparator method.","a) preconditions that are weakb) postconditions that are strong Explanation:- because if we override and make the precondition stronger, we will be violating the Liskov Substitution Principle.",scaffolding,Principle of least astonishment,yo-yo effect,Liskov Substitution Principle,"the method name is misleading. the method name is makeOneShapeFromAnother but we can see that the output shape is same as the input shape with change in the size.Also the method is doing two different things, calculating new radius/width and assigning shape.",It is inelegant way of coding because the guideline says that each class or method must achieve/perform one functionality at a time.,"we can calculate the radius/width in a different method. and call that method from this one.private double getRadius(Shape inShape, String type) {}",we cannot because then we will need to override each of their constructors separately while calling the new shape method.,"portfolio, share, record, gain","loss - loss is same as negative gain. Thus it has the same attributes and hence is at the same level of abstraction as gain.purchase price, current price- they are attributes of the share.",Portfolio and share.,"share/stock - The requirements state that-A portfolio is a set of stock positions. Each position is a quantity of a particular stock.A quantity is expressed as a certain number of shares.It can be sensed from these lines that the share is the basic unit(abstraction) and a quantity of shares comprise of the stock.so the current price, purchare price etc. attributes should belong to the share.",stock and share seem to have a parent-child relationship. but it does not make sense to make stock as a class and make it the parent of share. gain/loss seems to be a part of earnings.,PortfolioResponsibilities                                 Collaboratorsmaintains total earning                         share/stockmaintains total returnmaintains bonds and stocks                share/stock,class Exam2  end1.times do  class Exam2      def sayHello         puts hello from sayhello      endend,method1 overrides method0method2 overloads method1,method1 will be called- Horse eating hay Explanation:- a is declared as an animal though it is actually a horse. thus the eat method of the animal class is called and then specializations of that method(eat method with no arguments) are searched in the sub class(horse). Thus method1 in horse class is called,"By making method1 and method2 final we can avoid them from being overridden.signatures:- public final void eat() { //method 1      	System.out.println(Horse eating hay );   }   public final void eat(String s) { //method 2     	System.out.println(Horse eating  + s);   }",L[E]= EO,L[X]= XABCO,L[Z] = ZDAO,"L[Q] = Q+ (XABCO, YDBEO, ZDAO) = QXYZDABCEO",Strategy pattern :,"advantage : depending on the client use, the print method from success of failure class is called.disadvantage: no default class chosen. hence, if""Badrinarayanan, Deepu",,,,,,,,,,,,,,,,,,,,,,,,,,"Baliga Bantwal, Deepa",,,,,,,,,,,,,,,,,,,,,,,,,,"Brown, Tristian",If Java just used actual types then the soring problem would take so long or be as convoluted as it is. I say this because when Java decides which of a method to execute it first looks at the type and then searches through the signatures for what the object is defined as. The cause it to be more convoluted because if Java just look at the type of a method via class then it would just need to go to one place at runtime.,It does matter and you want a strong precondition because you want the code to operate in a  good known state and good (possibly weak) postcondition. Because you want to restrict operation and inform the client of the routine of what could happen in all cases. So in a perfect world the precondition would be incorporated into the postcondition. This can be done be saying exactly what will happen if the precondition is not satisfied.,delegation,LSP (The Principle of Least Astonishment),DRY Principle: Duplication Avoidance,Design Principle,Reusability,Because of how this specificically this code is written a new programmer would have a hard time expanding it and/or reusing it. This code can not be reused in a different setting and it would be hard to add shapes to it because of nested if statement and how data is utilized.,,"No,","Portfolio, position, Gain, records","Purchase price, current price",,Gains,Gains would be the parent class.  Short term and long term could be good sub-classes for gains. I think this would be a good relationship because gains could contain all of access the information for the different stocks. but short term and long term would perform the respective needed calculation for each situation.,"Responsibilites: have the names of the stocks, and know the stock values (via Gains)collaborators: Stocks , Gains","class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined  endend",method 1 --> overrides because it has the same signature as the parent classmethod 2 --> overloads because it has a different parameter list,It outputs either Horse eating hay or Horse eating (passed in string) because the two methods in the subclass overright the above method. So in Java based on how this method is class it will print either method 1 or method 2. This is also,"yea by making a method private it can not be accessed therefore it is hidden from the outside world. That was if the horse class method would not be overridden, because it can be accessed/seen outside of the class.",L[E] = EO,L[X] = XABCO,L[Z] = ZDAO,L[Q] = Q + XABCO + YDBEO + DAOL[Q] = QXDABCYEZO,This the Command Pattern. This program issues print request to objects. The code doesn't know what is being printed and it doesn't care. All it is concerned with is that the print job is successful/successful.,"An advantage is that any print job can be executed using this code, it is not printer or print job specific. Therefore this code displays completeness and reusability, and usability. One downfall of this pattern is it is very verbose and multiple objects can be created. There are certain situations where it might be good to use the command pattern because you only want one object to be created at a time.""Devaraj, Dilip","Taking iteration 2 example of sortcomp.compare(data[j], data[indexOfMax]) > 0)the types of the argument is Integer therefore the method public int compare(Integer o1, Integer o2) of Comparator class will be called.This would prevent any compilation error too as type of argument is Integer class and that compare method corresponding to integer called","a) preconditions  that are as weak as possibleFrom original postcondition, we can also weaken the preconditionto make it achieve correctnessb)postconditions that are as strong as possibleIf the postcondition is stronger than the original postcondition, there are values of x which satisfy the original postcondition but do not satisfy new post condition then we can catch more errors or invalid values",Migration,Principle of Least Astonishment,Yo-yo effect,Liskov substitution principle,Not Extensible as makeOneShapeFromAnother is made privateNot Maintainable,"No other class  object mthod can call makeOneShapeFromAnother as it is declared as private. Thus code is dead code.It is also difficult to reuse and maintain as makeOneShapeFromAnother new types like triangle ,square can only be added by modifying above code.",Have separate function for each shape typestatic Shape  circle(Shape inShape);static Shape  rect(Shape inShape);static Shape  cylinder(Shape inShape);,"Yes we can still rewrite by extending system-defined classes, as long as it not final.We can then override methods and return our specific Circle, Rectangle, and Cylinder",portfolio record dividendearnings,gain  - as it is of primitive type integer or floatshort term - as it is of type Time,earnings,"stock From stock,  record is generated that records the gain and calculates the tax due on the gain.A stock may also pay a dividendA stock may also pay a dividend is used as key abstraction","Bonds  can be subclassed as stocksMakes sense as some common functionality like purchase price, current price, and gain (or loss) is used.Advantage - more modular code and easier to correct system by changing parent class StockDisadvantage - If high coupling between stock and bond then issues like changing Stock behaviour afects Bonds",Repsonsibilitystock is soldcollaboratorrecord Repsonsibilitycalculate the total earnings collaboratordividend,"class Exam2def method_missing(meth, *args)    str = meth.id2name    puts  {#{meth} is not defined}  Exam2.class_eval do    define_method :str do    puts   {Hello from #{str}}    end  endendende = Exam2.new e.sayHello e.sayHello",public void eat()  overrides public void eat(String s) overloads,"Horse eating hay Object type a is Animal, it points to   Animal and closest match is public void eat() in Animal class. Then dynamic binding occurs and it finds the same method signature in Horse class and hence chooses the method public void eat() in Horse class","We can change signature or name of method public void eat() so that it is not matching Animal class therefore it does not get overriden.Change public void eat()topublic bool eat() { //method 1        	System.out.println(Horse eating hay );return true;     }Mthod 2 is already not overriden ,as it is only overloaded. Therefore can be the same.  public void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }",EO,XABCO,ZDAO,QXYZDABCEO,"design pattern is Strategy. Based on value of IPrint value , when print_operation.print(); is called the print method of Failure or Success is called (Different strategy is used based on value)","AdvantageThe point is to separate algorithms into classes that can be plugged in at runtime, ie This pattern helps when you need to choose an algorithm for a task depending on some ?parameter? of the situation.DisadvantageCannot be used directly with Generics.The disadvantage of a generic implementation is that strategies cannot be chosen at run time. Generics are a compile-time construct, so they must be completely satisfied before the program runs.""Didwania, Kaushal",,,,,,,,,,,,,,,,,,,,,,,,,,"Ezen TA, Aysu",,,,,,,,,,,,,,,,,,,,,,,,,,"Fang, Xiaozhou","If Java only uses actual type of argument to decide which methods to be executed, then the evaluation of method overridden is not necessary. Because no matter the method is overloaded or overridden, it can be immediately executed at the time the object in the same class call it.",,,Principle of least astonishment  (PLA?,,Interface,DRY,it will makes the code become heavy and unambiguous in sometime. And it may cause problems every time trying to write the code for the same functionality.,public interface MakeShape {}public class CircleMakeShape implements MakeShape{}public class RectangleMakeShape implements MakeShape{}public class CylinderMakeShape implements MakeShape{},,"Portfolio, gain, tax liability, dividend",,"Portfolio contains part objects like annual rate, gain, tax ability and so on.",total return. Because it,"yes, earning and total returning can be defined as subclass as Profit class which responsible for current issue, since both of earning and total returning involve gain, lost, tax and interest.With the subclass, we can easy to manager the prat of money making in this application. However, it may some disadvantages because some variables are not shared in earning and total return.",calculate gain        priceget profit or not       gain loss,"class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined    puts Hello from #{meth}    eval %{def #{meth}           puts Hello from #{meth}          end}         endende = Exam2.new e.sayHello e.sayHello",Method 1 in the Horse class overrides method 0 in AnimalMethod 2 in the Horse class overloads method 0 in Animal,"Output: Horse eating hay In Horse class, method eat() has been overridden which will print Horse eating hay. So though a is declared as a Animal object, eat() in Horse Class will be executed by looking for a' actual object type, which is Horse.","public final void eat() { //method 1        	System.out.println(Horse eating hay );     }     public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }",E,XABC,ZDA,QXYZDABCE,IPrint is the design pattern as it has been used in,"Fleischhauer, David",You then would not have to ask the object which class to call.  The code would be a lot simpler and easier to read.  Not so much control code.,"preconditions and post conditions add extra constraints to a given method or statement.  How weak and how strong they are should depend on their function.  For instance, If the programmer defines a musicFileOpen(..) method, a precondition might be that the method only accepts .mp3 files.  Another program could have the same exact method signature but allow opening or .mp3 and .aac files.  The two methods might be similar but they have different mre/post conditions.",abstraction,Principle of least astonishment,the yo-yo effect,LSP - Liskov substitution principle,"This is not very elegant.  If the programmer wanted to add more shapes, they would have to explicitly add them to the if then else chain.  Also, you should never ask an object what its class is.",,"you should create an interface that requires this method.  Then If you want to turn a shape into a circle, you should extend the interface to get the specific case.public interface makeOneShapeFromAnother{    static private Shape makeOneShapeFromAnother(Shape inShape);}","yes, these classes would then implement the interface.","portfolio, posiiton, shares, record","current price, purchase price",portfolio is an aggregation.  It contains positions.,loss.  A loss,"A gain can either be short-term or long-term.  Short-term and Long-term are subclasses of gain.  Yes, it does make sense.  The only difference between a short term and long term gain is their tax percentage.  So there is high code sharing between the two.",responsibility #1:  keep track of a set of stock positions      collaborator:  Positionresponsibility #2:  remove stock      collaborator:  Stock,"def method_missing(meth, *args)    puts #{meth} is not defined    eval %{def sayHello           puts Hello         end}  end",1.  method 1 overrides method 02.  method 2 overloads method 1       *would overload method 0 if method 1 did not exist,"output:   Horse eating heyreason:   First, java calls the method of the object type, not the type it was declared as so the Animal's eat method is not called.  Second, there is no parameter passed into eat in the main method so method 1 is called.","No, if anyone were to subclass the class Horse, they could override the methods.  There is no way in java to prevent this because java ALWAYS looks to see if the method is defined in the subclass first.",EO,XABCO,ZADO,QDABCEO,Strategy.  The programmer can dynamically change which method gets called when printMethod() is called.  It allows the programmer to easily adapt to a different scenario.  The pattern is used when you to choose an algorithm based on some parameter of the situation.,The advantage is that it allows the programmer to adapt to different situations."Ge, Qian",,,,,,,,,,,,,,,,,,,,,,,,,,"Gong, Fengyuan",,,,,,,,,,,,,,,,,,,,,,,,,,"Han, Lu","Then we can simply use the actual types of arguments to call the functions overrided by the subclasses, like c++ languages. Which can be decided in the compile time, not like dynamic method invocation is decided in the run time.","To achieve correctness, we should strong our preconditions, and weaken our postconditions. For an extreme example, we can make expression false for precondition, so any methods can be satisfied with this precondition. And we can make true for postcondition, and any methods can be verified to be called. To achieve correctness, we need to speicify our precondition and postcondition.",skelinton.,Principle of least astonishment,dynamic binding,Liskov Substitution Principle (LSP),could use inheritance for equalsfunctions of all types.,"when you want to add some more types such as ball or square, you need to edit the method itself.","Shape circleequals(Shape ShapeIn, string typeOut)Shape rectangleequals(Shape ShapeIn, string typeOut)Shape cylinderequals(Shape ShapeIn, string typeOut)","yes, we can override the system-defined classes. And make it for what we can specify.","position, gain (short-term, long-term), stock, record, portfolio","The portfolio manager: since it can not be represented in the system. The purchase price, and a current price which are just values, can be used as parameters in stock class.",The system holds a protfolio which contains stock inside.,stocks can be treated as prices or as a object,"gains: short-term gains, and long-term gains.the gains could be implemented as an abstract class. we can add some more specify gains as another subclass in the future.","stock classResponsiblities: 1. know the current value        2. know the staticstics like rate, gain, loss and taxCollaborator: 1. none2. Gain",class Exam2class_eval do  define_method :hi do  puts # hi is not defined.  endendend,eat() in the Horse overrides the eat() in the Animal. eat(STring s) in the Horse overload the eat() in the Animal,Horse eating hay,We can use an interface.,EO,XABCO,ZDAO,QXYZDABCEO,command pattern. Since it is used to call sucess and failure print command.,"Advantage: It is implemented as an interface, so the sucess and failure methods can be implemented seperately.Disadvangtage:""Hanumantha Gowda, Raghu","Dynamic method invocation was used in the sort routine to overcome the inelegance of downcasting for each type of argument. If java were to use the feature similar to CLOS, then downcasting need not be required i.e. since the language would use the actual types of arguments to decide which method to execute, polymorphism and dynamic method invocation will not be required.",To achieve correctness preconditions should as weak as possible and post conditions should as strong as possible.Preconditions should be as weak as possible as the input requirements of a routine should be as general as possible.Postconditions should be as strng as possible as the output of he routine should be as precise as possible.,alias,The Principle of Least Astonishment,Implementation Inheritance.,Liskov Substitution Principle,This violates the code reuse rule of object oriented style,Unnecessary code would be added and hence the modifiability and maintainability of the code will be lost,"A method can be included in the Shape interface to make modifications to the existing shape and return the new shape.Class Shape{public abstract Shape modShape();}Class Circle{public Shape modshape{x,y//Implementation to return the new shape with radius based on the existing shape's area and inputs x and y}}Class Rectangle{public Shape modshape{x,y,height)//Implementation to return the new shape with width based on the existing shape's area}}Similarly for a cylinder.",It would not be possible to rewrite the code to follow the style guidelines as we will not be able to extend the functionality of the classes in Java.,"portfolio, position, earnings,record",price should not be a key abstraction as it is more relevant being an attribute of the stockdividend should not be key abstraction as it is more relevant being an attribute of the stock.,"portfolio(whole) contains position (whole) which in turn contains stocks as well as bonds.earnings can include gain , interest and dividends",holdings can be used as a stock as well as a bond.,Class: HoldingSub Class: Stock and BondSubclassing need not be done as Bonds can be treated as Shares except that the dividend will be called interest.,"Responsibilty1 : Create_record_to_remove_stockCollaborator : RecordResponsibilty2 : Calculate_total_earningsCollaborators : holding, earnings","class Exam2 def method_missing(method)    if(method.id2name eq  sayHello)    puts sayHello is not defined     class &lt;&lt; self        class_eval do            define_method :sayHello do              puts Hello from sayHello           end    end  end    end endNotes: We can catch the method missing using the runtime featre method_missing method. We check if the method name is say hello. If it is sayhello, a new method is defined in the class which outputs the required string. The next time the method is called, the method sayhello is called instead of method_missing.",method 1 overrides method 0method 2 overloads method 1,output: Horse eating hayIt prints the above output due to dynamic method Invocation which observes that the subclass horse overrides method 0 by method 1 and hence calls method1. It uses the subclass method since Animal a is referred by new Horse(),We can use the final modifier on the methodspublic final void eat() { //method1and public final void eat(String s){ //method 2will do the trick,EO,XABCO,ZDAO,QXYZDABCEO,Strategy pattern,Advantage : More OO way of programming as it involves polymorphismDiad: would be very difficult to capture dynamic changes by inheritance"Hegde, Bharath",,,,,,,,,,,,,,,,,,,,,,,,,,"Jefferies, Robert","If the type of the argument was used rather than the value of the object being sent the message, this would allow the compiler to make the determination of which method to call at compile-time instead of run-time.","As far as correctness is concerned, you from any formula that holds you can obtain another formula that holds by either strengthening the precondition or weakening the postcondition.  It is also possible to make conditions that will make the program execute correctly no matter what (if the precondition is 'false', and the postcondition is 'true').  In order to write pre and post conditions that will help achieve correctness, without limiting the input range of the code, it is best to use the strongest USEFUL precondition -- the strongest one that will yield output containing 'good data', and the find the weakest postcondition that will satisfy that precondition.",In Ruby: ActiveRecord.  More generally: object-relational mapping.,principle of least astonishment,,Liskov Substitution Principle,"The single responsibility principle.  This function includes calculations that should belong to several other classes; it doesn't do one thing.  This method manually calculates data that should be private to classes that implement the Shape interface.  For example, the radius of a circle should be private to the circle class and should be retrievable with some kind of getter method.","If someone wanted to extend this to work with more sophisticated shapes (e.g. Triangle), to remove support for a shape, or to do additional things with shapes other than testing their equality and calculating radius, height, and possibly width, then this function would have to be modified.  This might introduce errors and break some other code.  In other words, it isn't extensible or maintainable.",Use a Strategy pattern.  The function should decide which class methods (belonging to the Circle/Rectangle/Cylinder classes) should be called based on the type of the input parameter inShape.  Getter methods would need to be written in the Circle/Rectangle/Cylinder classes:public getRadius();public getWidth();public getHeight();,"Instead of being rewritten, it would be better to include the functionality in each class. The best way to do this would be to overload the constructor for each class. For example, the Rectangle class would have a default constructor with parameters x, y, width, and height.  It would also have a constructor accepting parameters x, y, and a Circle object.  It would also have a constructor accepting parameters x, y, and a Cylinder object",PortfolioStock -- a single share (contains current price)BondRecord,Price -- it's a primitive type. Portfolio -- it would contain the same information as Stock.,One Portfolio owns all of the Stock and Bond and Record objects that that person has acquired.,"Stock is a bit ambiguous.  A portfolio contains a set of stock positions, which is a quantity of a particular stock.  A quantity is a number of shares.  In other words, 'stock' and 'share' are relaly the same thing; if you own 'stock', you have a set of shares of some publicly traded company.  Stock is the key abstraction, because sometimes companies choose to split their stock; meaning the number of shares is doubled, and each share is worth half as much.",Portfolio could be subclassed to contain,"Portfolio is responsible for generating a record when stock is sold.  The collaborators for this are the Stock class, which will be able to report the current price, and the Record class, which the Portfolio class will create a new object of. Portfolio is responsible for generating the total return at the end of the year.  The collaborators for this are the Stock, Bond, and Record classes, which will each report their unit value.","class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined    define_method(:meth) do      puts Hello from #{meth}    end  endende = Exam2.newe.sayHello",Method 2 overloads method 1.  Method 1 overrides method 0.,"it prints Horse eating hay .  This is printed because Method 1 overrides the eat() method of the superclass (Animal).  The main() function of the program calls eat(), and the Just-In-Time compiler knows that eat() has been overridden inside the Horse class, so it executes that method.","Use, use the 'final' keyword in the method signatures. public final void eat()               <--Method 1publid final void eat(String s)   <--Method 2",,,,,,"Job Amarnath, Judith","The lecture deals with the sorting program.Suppose you are asked to implement a class whose purpose is to sort arrays of data in place, there is a lot of code involed.Three questions arise.How many sort methods to implement in Sorter class.The code of these methods are almost identical. Will ther be code reuse.Whether we always want to sort in one fashion.We want avoid duplication ande also develop an elegant code.To solve many problems that we discussed in class, we can use a Comparator class that has a compare method and takes two objects as parameters. Then this method is the one that will always be called by the generic sort routine.We can now eliminate other compare methods in the Comparator class and replace them with a general one.It has already been taught that the OO way of doing thingsis to use polymorphism instead of conditionals as we have in the original sorter routine.Our final modification of the code will be to make Comparator an interface and create several classes that implement Comparator, one for each type of data.This can make use of the java.util package.Now a client can use the sort method by just passing the array and a StringComparator as parameters to the sort method.This is a strong place where subtype polymorphism is uesd. We use it in our arrays  and objects in the arrrays and complete a generalization of the sorting algorithm.We also clean up the Comparator class by using interfaces and now the Sorter will need only one sort method.","A precondition is a condition that must be true inorderfor a mthod to work.A post condition tells what the method guarantees will happen when executed.From the lecture 18: from a formula that holds, you can always get another one that holds by strengthening the	precondition	 or weakening the 		postcondition      .If the preconditions a weak, it will lead to less problems on the side of the client. Also we can weaken the pre condition and use defensive programming. When you know errors arre likely to happen, make sure your methods can defend against such input by doing something expilict in a way that is helpful to the users of the methods.If a caller can guarantee that the preconditions ara all satisfied, the callee guarantees that the postconditions will be satisfied after the call.It is on the other hand necessary that the post conditions are strong as the client has to be satisfied from the service provided as the client has already satisfied the pre conditions.There are situations that require that these condition guide lines can be ignored as mentioned in the text book.If extra code needed to test for legal input is needed and if the test fails the exception throw will be very expensive in some case when it comes to resources.Eg: binary sort search.To conclude, the preconditions can be made so that it eases the part on the client.But the post conditions need to be comparatively stronger to guarantee efficient results.But there will be cases where these guidelines can be ignored.",,Principle of least astonishment.,,Liskov Substitution Principle,"We know that in OOP, a class must perform one function and do it well. Here there are too much of clutter as far as coding goes.The functions to calculate the area of the object can be aasigned a particular method and then implemented to avoid cumbersome code.Also the documentation is not suffiecient and provides no uses to the reader.In OOP and for elegant use of software, the name makeOneShapeFromAnother must be replaced by a proper name. Further the outShape is a name that does not make proper sense.","Because of this code violation, the program becomes cumbersome and the reader or user of the program is forced to spend more time on it.Then there could have been an implementation for the area calculation of these pbject that would have minimized the many lines of code.Also a class is likely not to perform well if it does not fit in a screen of the user at one time as seen in the lectures.","There could have been a method defined and called by the name say, area and this method could be used to perform the funtions namely to calculate area with  the given formula by choosing the appropriate formula according the parameters passed. Also the names of the variables and methods can be chosen properly.","It depends on whether the user wants to implement the codes directly from the library or make changes to it.If the changes are very big, then it is better to implement the user developed code, else they can be used from the system defined classes.",porffoliopricesharesearnings,"short term , long term.The term depends on the length of time.value and price represent the same object so should not be used .The value of the stock is the current price thats why.","the portfolio manager calculates the total earnings  as the sum of gain, interest and dividends hence this is an aggregation.",value and current price The value at any particular time for the stock is the current price.,"Yes There could be a class for calculating the earnings that can take information from the gain calculator, interest calculator and dividend calculator.Thus there can be superclass and a subclass.Since multiple inheritance cannot be used in some places, interface can be implemented.",Responsibility: Position look uppricetermearnings calculatorCollaborator:current price,,override: method 1 overrides method 0.method 0 and method 1 have same eat().overload: method 2 and method 0 are overloaded. Since eat takes 's' in method in Horse and eat() is in Animal.,The output is Horse eating hay.The reason is that the method that is called namely eat() or a.eat() has no arguments.The method 1 is called here so the output is Horse eating hay.,"If the Horse class has to be modified so that the eat methhods are not overriden, then these methods must take different parameters or they must have different signatures.But still can contain the same name eat.If method 1 take integer values and the method 2 take string values, the methods are overloaded but not overriden.",EO,XABCO,ZDAO,QXYZABCDEO,"The pattern is Strategy pattern.This pattern helps when you need to choosean algorithm for a task depending on some ?parameter? of the situation.Strategy is used to customize an algorithm. A strategy must have a number of methods specific to the algorithm. Most often the strategies will be instantiated immediately before executing the algorithm and discared afterwards.In computer programming, the strategy pattern (also known as the policy pattern) is a particular software design pattern, whereby algorithms can be selected at runtime. Formally speaking, the strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.","Advantage:It is highly advantageous when at any time you have any object that knows what it needs to do but not how to do it.a class that performs validation on incoming data may use a strategy pattern to select a validation algorithm based on the type of data, the source of the data, user choice, and/or other discriminating factors. These factors are not known for each case until run-time, and may require radically different validation to be performed. The validation strategies, encapsulated separately from the validating object, may be used by other validating objects in different areas of the system (or even different systems) without code duplication.Disadvantage:A lot of factors can affect which strategy to use. And these factors canchange dynamically. It would be very difficult to capture this by inheritance.""Kalkeri, Abhishek",,Strong postconditions help achieve correctness because it allows cases to enter a module through weak pre conditions but will not allow faulty code to exit. Thus it is necessary to have a strong postconditions for correctness.,metaprogramming,elegance,yo yo pattern,Liskov's Substitution Principle,Returning an object,Returning an object is not good because the compiler creates a dummy object for the returned object. IF the size of the dummy object is high then more memory will be wasted.,,,1. portfolio2. record3. position4. earnings,,gain is either short term gain or long term gain,,,,"def method_missing(meth, *args)puts #{meth} is not definedendExam2.class_eval dodefine_method :sayHello doputs Hello from sayHelloendendExam2.new.sayHello",method 1 and method 2 are examples of function overloading because the function name is the same but the signature is different within the parameters. Method 1 overloads method 2 because no parameters is passed in the method (eat) invocation. Method 0 overrides method 1.,The output is generic animal eating generically. The reason being that horse is the subclass of the class animal. The signature of object a is of type Animal. Thus when the eat method is invoked the search for the matching method begins from the top of the inheritance graph i.e from class Animal and stops when a match is found. In this case it will stop when the eat method from Animal is encountered.,We can modify the signature of the object as follows:Horse a = new Horse();a.eat();a.eat(grass);Since the signature of the object is Horse the search for matching method begins from the subclass i.e horse class and the superclass is not searched. Thus method 1 and method 2 will be searched first for a potential match. Thus the output of the above snippet will be Horse eating Hay Horse eating grass,,,,,The design pattern is the strategy pattern. The strategy patterns allows algorithms to be selected at runtime.  The strategy pattern as the name suggests has a method defined for all the strategies. The method that is invoked is determined only at run time.,Advantage:The Strategy pattern offers an alternative to conditional statements for selecting desired behavior. When different behaviors are Encapsulating different behaviours in different Strategy classes eliminates the need for conditional statements.Disadvantage:1. Strategy pattern increases the number of objects in an application.2. A client must understand how Strategies differ to be able to select the right strategy"Karli, Pratyush",,In some cases where data provided has to have correctness then strong prconditions are required and in som conditions where the output has to have correct values then strong post conditions are requierd.,,,Multiple Inheritance,Inheritance,all the methods are defined in the same class,If all the methods are defined inthe same class then it may lead to deadlocks in obtaining data for processing.,all the methods for different design must be distributed,yes if they are defined classes then each calcualtion can be impimented as a method,"portfolio, shares, record(for taxes), earnings",1. short term and long term : they need not be key abstractions because they can be implemented as an attribute under  the record for taxes class which can be used to calculate taxes. 2. purchased price and current rice: these can be implemented  in shares class that maintains all the price details about a stock.,"earnings ==> dividend, interest, gain.",earnings: it has been tried to group under portfolio so as to calculate the earnings of each portfolio and also the total return term makes it even more ambiguous as to make it a sub section of the returns.,"positions can be a sub class of portfolio class. It maintains the records of each company shares that are under the portfolio. Here, considering a position as a sub class is useful so as to have a clear distinction between the various company shares that are maintained. Advantages:1. Helps in having each company record for itself.2. The tables under this class can be easily connected with other classes such as shares and earnings.3. there are various values stored under positions which require a separate class.4. properties of positions in common can be defined in the portfolio class without having to suffer the performance consequences and relational design restrictions inherent in other strategies.Disadvantages:1. relations to the un-mapped portfolio class can be really inefficient.2. If the concrete subclass is not known, the related object could be in any of the subclass tables, making joins through the relation impossible. 3. Subclasses can even use repeated primary key values, forcing the JDOR implementation to record more than just the related primary key values in the database.","Responsibilities: 1. To maintain quantity of stocks.Collaborators: shares, earnings, records.2.  To maintain records about bonds.Collaborators: earnings, records.","Missing method:class Exam2  def method_missing(meth, *args)     puts #{meth} is not defined   end end Dynamically Defined:c = Class.new e.class_eval do   define_method :sayHello do   puts Hello from sayHello   end end To call that method:e.new.sayHello",1,horse is specifically called soHorse eating hay,,,,,,,"Kulkarni, Rishkul",,,,,,,,,,,,,,,,,,,,,,,,,,"Li, Chao","in the sorting method we have mentioned in the class, there is one step that we have to determine the object type of what we want to sort, like, we have to design a interface of comparator, and we have StringComparator and IntegerComparator to use this interface to separately decide what kind of type that object really are:  String s1 = (String) o1;  String s2 = (String) o2;  return s1.compareTo(s2);like above shows in springcomparators, and the same for the integer comparatorthe sort class do its own business : public static void sort(Object[] data, Comparator comp), it don't judge what type of the object is, the Comparator that we have shown above will tell it. Thus, we the dynamic method invocation in java, we can save our code lines of comparator, the Java runtime environment will tell the comparator what actual type of the object is, so we don't have to test and convert them","I think weak preconditions and strong post conditions could be better, if we weak the preconditions, that means we have to made our code robust as possible to handle many exceptions, we can using like method_missing (in ruby) to eliminate or handle error situations, but the  post conditions should be as strong as possible. That means, if the precondition has been achieved , or even not fully achieved, we should guarantee that we output what as expected. It's a kind of contract thinking in coding, the different is even if the client is not fulfill his responsibility, the server should serve as much as possible",,Least Astonishment principle,C3 Linearization,Liskov substitution principle,"1, the method name is too long2, this method seems to do too many things at the same time using if ... else if ...else3, the method should be public so that it can be invoked by other classes or objects4, for one method, if you made changes to data, then you should not return a value","1, the method name should be clearly present what this method do, with verb and its operated objects, like getSize(). Long method name have display problems2,this method should let other method or class to handle the if... else... segment, the only thing that the method should focus is to change one shape from another, not to judge what the shape is. That is: do one thing and do it well.3 For o-o language, objects both have their own responsibilities and should collaborate to do one complex task, that's require message sending and invoke between different methods, classes and objects. A private method can only be invoked inside the class body, which is not very o-o for this situation 4, if a method want to return a value, then it should not make modify on this value, just return it. I think modify value and return value for this problems should be carried by two different methods","ShapeType(Shape inShape){return shape type}ShapeGetShape() {//get the shape data, like area, radius, width, height, and its position }","If they are system-defined classes, there are2 ways to rewrite them.  Another way is to using inherit, but you have to inherit all method in the superclasses, and you may probably want to override the methods to define your own. Besides, we can also the example given as the java stackpublic class MyStack{ private java.util.Stack stack; public MyStack() { stack = new java.util.Stack(); } public void push(Object o) { stack.push(o); } public Object pop() { return stack.pop(); } public object peek() { return stack.peek(); } public boolean isEmpty() { return stack.empty(); }}we just use part of the system classes.But there may be problems, for inheritance, since you have inherit everything from the super class, you may probably meet some unexpected problems if you not study all the part of the super class",portfoliostocksbondsearnings,"1,gain&loss, it can be calculated by the difference of buy and sell value2,record, record can be generate in the portfolio class3, price, it's the state variables of stock",stocks and bonds are all parts of portfoliogain and loss is also a part of earnings,"Since each position is a quantity of a particular stock , and a quantity is also expressed as a certain number of shares. I think shares and quantity may be ambiguous","long-term & short-term stocks are subclasses of stock., because each one has all the attributes of stocks, but a different way of calculating a tax. But I think the short-term & long-term can also be a property in stock, and the only thing we want to distinguish subclass and superclass is one property of class, I think we may also substitute it with a class variable",Portfolio Responsibilities 1keep track of stocks and shares2call other method to calculate the total earnings Collaborator:earning calculator,"I think we can use eval hereclass Exam2endc = Exam2.new c.class_eval do   define_method :sayHello do   puts Hello from sayHello   end end c.new.sayHellowe can also define it directly in our classclass Exam2  eval %{def sayHello           puts Hello from sayHello          end} end m = Exam2.new m.sayHelloThe eval can define a new method with a form of strings to a class after that class has been defined, so if we first define a class without defining a sayHello method, it will output sayHello is not defined. Then we dynamically defines sayHello method eval, then the output will be Hello from sayHello we can arrange the sequence as:class Exam2end e = Exam2.newe.sayHello c = Exam2.new c.class_eval do   define_method :sayHello do   puts Hello from sayHello   end end c.new.sayHello","In Horse class, method1 override method0 in superclass because they have same parameter typemethod 2 overload with other methods because it has different parameter types","it's print Horse eating hay althogh a is defined as an animal, but it is actually a Horse. For dynamic invoke, the compiler will consider its actual class, so it find method in the Horse class instead of a animal class, the parameter type is void, so it calls method1","overriden means the method in subclass has the exactly same signature in the super class. So we can modify the parameter type to make overriden a overload. Thus we can change the method1 to  public void eat(any other parameter type but not void), then the super class method 0 will still be valid",EO,"L(X)=(A,B,C)=[AO,BO,CO]=ABCO","L(Z)=(D,A)=[DO,AO]=DAO","L(Q)=(X,Y,Z)=[ABCO, DBEO, DAO]procedureABCO, DBEO, DAO --> A and B in the tails of 2,3. Thus to 2, D is not in the tails of any, the first is DABCO, BEO,AO --> B is in the tails of 1, Thus go back to 1, start over, now A is not in the tails of any, the second is ABCO, BEO, O--> now B is not in the tails of any, so B is the thirdCO, EO, O-->then it is clear that the sequency is C, E, OThus: we have :DACEO","interface design patern. it can avoid inherate from abstact superclass, but can still take its advantages","Li, Xiaodong",,,,,,,,,,,,,,,,,,,,,,,,,,"Mao, Rui",,,,,,,,,,,,,,,,,,,,,,,,,,"Nagaraju Mythri Nagaraju, Mythri","In JAVA, priority is given to the declared class of the object rather than the types of the arguments in the method calls. So JAVA decides which overloaded method to call by looking at the   - declared type of the arguments  - and then binding to the most specialized object that can receive the message.If it considered only the actual types of the arguments, it would only have to look in the corresponding class which is the same as the type of the arguments in the method.","A precondition is a condition that must be true for the method to work. A post condition tells what the method guarantees will happen when it is executed. In case of implementation inheritance, It is acceptable to make B a subclass of A only if for every public method with identical signatures in both A and B, the preconditions for B?s method are no stronger than the preconditions for A?s method and the postconditions for B?s method are no weaker than the postconditions for A?s method.",Database migration,Principle of Least Astonishment,yo-yo effect,Liskov Substitution Principle,"The code given above is using conditionals and there is duplication of code inside every if block. So it violates the object-oriented style. Also, if any object other than circle, rectangle and cylinder are created, the code assigns a cylinder object to the object outShape.","It is bad to use conditionals because the code can get very elaborate of more shapes, other than the shapes that are currently existing(circle, rectangle, cylinder) are introduced.","According to the style guidelines, all the other shapes that might use this code must also be considered. And there should be a generic code to assign shapes to them.We can have an abstract class which has the common methods that the if loop in the above code contains. And each of the shapes can be passed as an object to a class which implements this interface. We can also have a shape for each class.public abstract class makeShapeFromAnotherShape(Shape inShape){     abstract int calculateRadius(){ ...code to calculate radius...}     abstract Shape outShape(){}}Shape inShape = new Circle();Shape inShape = new Rectangle();public circle extends makeShapeAnotherShape(circle){...code to assign circle to a circle...}public rectangle extends makeShapeAnotherShape(rectangle){...code to assign rectangle to a rectangle...}",,-Stock or bond holdings-Shares-Stock positions-Portfolio,-purchase price-loss,Earnings,Position is used ambiguously in the requirements because it is the quantity of a particular stock and a quantity is a certain number of shares; it does not say exactly how many number of shares,"Position can be a subclass of portfolio because both of these classes implement almost the same functionality. A portfolio is a set of stock positions. Each position is a quantity of a particular stock. Rather than making position a subclass of portfolio, both position and portfolio can be made subclasses of another abstract class which has the same functions. Because although they have the same functionality , portfolio will manipulate a set of stock object and the position class will manipulate a single stock object",Responsibilities:- Calculate total earnings- Calculate total returnCollaborators:- Position- Purchase price- Current price,exam2.class_eval dodef print Helloif not yet instantiated     puts say Hello is not definedelse  Hello from SayHelloendend,The method void eat() of the Horse class overrides the void eat() method of the Animal class. The method void eat() in the Horse class overloads the method void eat(String s) of the Horse class.,"Output : Horse eating hayThe method void eat() in the Horse class overrides the method void eat() in the Animal Class because although the object a is declared as an object of animal class, it creates an instance of the Horse class (i.e. a = new Horse()).","By having an abstract method eat() in the Animal class, we can ensure that always the eat() methods of the Horse class are implemented.",EO,XABC,ZDA,XYZ,"Strategy Pattern, because in each case(success/failure) , it's following a different strategy",Advantage:Hierarchies of Strategy classes can be used to define a family of algorithms or behaviors for contexts to reuse.Disadvantage:Strategy pattern increases the number of objects in an application."Nienstedt, Zachary",,,,,,,,,,,,,,,,,,,,,,,,,,"Nyayachawadi Ananth, Deepak","By using the actual type of argument , the complier can directly look into the actual class of the algorithm thereby choosing the required algorithm as declared instead of choosing the algorithm of the declared class.","Each one has its own advantages and disadvantages. Pre-conditions are an obligation to the client.  It is better to have strionger pre-conditions. If the pre-condition is weak , the method might  go into an infinite loop, or even crash the system .Havin weaker postconditions is better. By having weaker pre-condtions we are ensuring that the supplier does not need to do much work in checking the preconditions.",Object Relation mapping.,Principle of least Astonishment,Yo-Yo effect,Liskov's Substitution Principle,Each method should be perform only one specific task and perform it well.The method not only calculate the area of inShape but also calculates the outShape and what outShape should be assigned.,"All the shapes ( like square , circle ) are being evaluated in one method. This makes it hard to track the code in case of any errors.",We need to distribute the control . i.e. We need to create a method for each inShape and call the appropriate method from this method. This way we can ensure that there is one method for each inShape which does only one job of returning the particular  outShape.static public Shape makeCircleFromAnother(Shape Inshape)static public Shape makecylinderFromAnother(Shape Inshape)static public Shape makerectangleFromAnother(Shape Inshape),"Yes we can. Determining on what outShape is required , we can make a call to the draw method in these classes and provide the required parameters ( such as radius ) which then draws the required shaped and returns it to this method.","portfolio , shares , divdend , totalreturn , interest , record",Current price is a numeric value. Hence it is not required to implemented as class. Purchase price is not required to be a class since there is no need to modify that in the program.,Portfolio holds stocks.,Total return is ambiguous. It is not clear if the total return is calculated and how dividend is used to acheive this.,Record is a subclass of portofolio.,Collobrators : position and  report.Responsibilites : Generate a report in case the protfolio is removed.                          Store stock positions.,"1)  Define the method_missing method in the Class like below.  def method_missing(meth, *args)    puts  #{meth} is not defined     end# This prints sayHello is not defined.2)   In order to call sayHello we need to define a new method sayHello as below. def sayHello puts  Hello from sayHelloendDynamically we need to call the sayHello from the method_missing. Hence make the following change to the method_missing method.def method_missing(meth, *args)    puts  #{meth} is not defined     sayHello     endThe makes a call to the sayHello method and prints Hello from sayHello",public void eat() in the Horse class overrides the public void eat() of the Animal class ( i.e. method 1 overrides method 0)method 2 overloads method 1.,"The output of the program is Horse eating hay. This is because when a.eat() is called , the method 1 is executed. Since method 1 overrides method 0 which Horse inherits from Animal , the method 1 hides the implementation of method 0.",By having different signatures to method 1 and method 2 we prevent the methods from being overriden.,EO,XABCO,ZDAO,QXYZDABCEO,Strategy pattern is being used here. Based on whether the print is successful or failure we call the approproiate failure or success algorithm.,"Advantage : If you have several different behaviours that you want an object to perform, it is much simpler to keep track of them if each behaviour is a separate class, rather than in the body of some method.Also the algortihms can be chosen dynamically.Disadvantage : All algorithms use the same Interface ( IPrint in this case )  and  Also there will be increased number of objects.""Ojha, Unnati",,We want preconditions that are as weak as possible and postconditions that are as strong as possible. Consider an example below X>=9  X= X+5 and X>=13 We can see that in this case we are not using the weakest precondition (or similarly strongest postcondition) In this scenario there is a case where the program may not have done the intended job BUT the precondition and post condition are both satisfied (i.e. case when X =9 and then the program may just add 4 instead of adding 5 which lets X=13 after the 'flawed' program has executed). In order to help avoid this kind of problem we should modifiy the pre or the post condition by either having X>=8 (i.e. a weaker precondition) OR having X>=14 (A stronger postcondition) to make sure the program will achieve correctness.,Migration,Principle of Least Astonishment,The yo-yo effect,Liskov Substitution Principle,,,,,"portfolio, record, share, gain",earnings - it is more of a method that should exist a portfolio not a class in itselfloss - it is just the negative of gain so can be handled using the gain class. We don't need another class for it,gain  is a combination of short-term gain and a long-term gain,"gain - first it is defined as the difference between the value of the stock when it was bought and its current valueAlso it is is said that the gain may either be short term or long term. If it is already defined as a difference between current value and its value when it was bought, what does it mean to have short term and long term gain??The first use represents a key abstraction","Bonds could be a subclass of Stocks or better yet stocks and bonds could both be subclasses of a third class that contains pruchase price, current price and gain methods. Then stocks can have a payDividend method and bonds can have payInterest method. Advantage - Code reuse, Bond is-a Stock, Disadvantage - Necessity to create a new third class","calculate total earnings - Collaborate with gain, interest, dividend classcalculate total return","class Exam2def method_missing(meth, *args)puts #{meth} is not definedeval %{def #{meth} (*args)puts Hello from #{meth}end}eval %{#{meth}}endend",method 1 overrides method 0method 2 overloads method 1,"Horse eating haya is declared as an animal, so the first place the program looks for the method signature is in the Animal class. It finds the method in animal class. And since a is instantiated as an horse, it looks in the horse class to see if there is a method that matches the signature of eat method in animal. It finds method 1 and executes it.",name the method differently,EO,XABCO,ZDAO,QXYZDABCEO,"Command Patternthe command pattern is a design pattern in which an object is used to represent and encapsulate all the information needed to call a method at a later time. This information includes the method name, the object that owns the method and values for the method parameters",Advantage - can be used for redo - undo operationsDisadvantage - it works for very generic cases"Pathak, Nidhi",if Java used the actual types of arguments to decide which of several methods to execute then we would always check for the sub class methods and ignore all superclass methods that has beenSorting problem would be easier as actual type of class will be considered alwayswe can skip the interface implementation part as now :Comparater cmp = new StringComparater() will not work as expected.,strong preconditionsand weak postconditionsstrong preconditions ensure that program always output the correct precise value and weak post conditions offer a large domain of outputs to be given to users.,ActiveRecord,Principle of Least Astonishment,Yo-Yo effect,Liskov Substitution Principle (LSP),1) A method should do one thing only and do it well : here function is trying to do multiple things simultaneously hence violation this rule.2)Well-designed procedures also promote reusability : here we are doing lot of code duplication,here methods is trying to do multiple things simultaneously. Functionality of a methods should be specific and should not include word and when we trying to explain what function actually  does. It is using lot of conditional statements and code might not fit into a computer screen after we add more functionality in to it.Additionally naming conventions for methods and variable id not followed properly. it is too long makeOneShapeFromAnother and x y does not convey meaning,"rename method to shorter name :  ConvertShapeuse xposition and yposition instead of x,y.getCircle() getRectangle() getCylinder()","yes we can define an interface for comman shape and let circle,rectangle and cylinder inherit it.","porfolio, earning ,record,stock,bond",purchase price /current price :- because they just hold a single numeric value which will either be assigned or calculated.tax:- this value is calculated in some function. and returned as a return value of that function. It does not have any attributes as such .,portolio contains stock,gain 1)gain is defined as the difference between the value of the stock when it was bought and its current value2)the gain may either be short term or long term3)A negative gain is called a loss,"1)stock and bond can share a superclass because only functionality that is diffrent in them is : stock calculate dividend and bond calculate interest. So they can define super class for comman attributes likepurchase price, current price, and gain (or loss)2) gain can have sub classes long term gain and short term gain as functionality only differ in calculation of tax calculation. rest all functionality is same.","1)keep track of a set of stock or bond holdings :collaborator : stock and bond2) to calculate their current value and other relevant statistics like annual rate of increase, gain or loss, and tax liability :collaborators :  earning,stock,bond",class exam2define_method(:str) do    puts Hello from #{str}enddef method_missing(meth)    str = meth.id2name   puts   #{str} is not defined.   str.call  endend,method 1 in horse overrides method 0 in animalmethod 2 overloads method 1 in class horse,"output is : Horse eating haybecause when a.eat() is called , since a 's declared type is Animal, it start searching for method defination in class Animal. As soon as it encounters eat() in Animal, because of dynamic method invocation, it check if there is any other specialization of method eat() in class horse because the actual class of a is Horse. It encounters an overridden method in horse class and hence calls eat() in Horse.","1) By declaring ,methods as final.2)i can do so by implementation of delegation. Instead of inheriting the Animal class, i will create the reference of Animal (object) in horse class :-public class Horse  {     Animal abb     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }     public void eat() { //method 1        	System.out.println(Horse eating hay );     }     public void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}",EO,XABCO,ZDAO,QXYZDABCEO,Adapter Pattern is used here. As we are using interface as a wrapper class between the perform operation and success and failure,Advatage :-two incompatible classes/objects can communicate with each other through interace / wrapper defined between themdisadv :- there is a possiblity of code duplication and less code reuse."Permana, Sofie",,,,,,,,,,,,,,,,,,,,,,,,,,"Prasanna, Sreepathi","If we would use the actual types of arguments then, there is no need to have a comparator interface and no IntegerComparator and StringComparator class. We can just have one class which have two methods one for Integer and one for String since we can distinguish based on the argument types.","To achieve correctness, we have to have strong postconditions. Because having strong postconditions means that, your programs behaves correctly and is producing right output most of the times. preconditions can be weak as possible because its enough to validate the inputs you are passing and strong post conditions will ensure that the program is behaving correctly.",,Principle of least astonishment,Yo yo effect,Liskov substitution principle,inheritance ( code reuse ),Because you could reuse the code and make the subclasses to inherit the code avoiding any duplication. Also code cannot be maintained. Also any shape apart from rectangle and circle wouldn't qualify as cyclinder.,"public void ComputeShape(Shape, radius, width, height, area){}",Yes. I would rewrite the code.  To make the code more structured and to avoid code reuse I would construct my program to have something like this. ( avoiding style guidelines)Interface Shape{}class Circle{}class Rectangle{}class Cyclinder{},"Portfolio,Record,Position,Gain,Bondstock",1. purchase price and current price2. Earnings and dividend,A portfolio is a set of stock positions. Each position is a quantity of a particular stock.,price and value.,"Gain ShorttermGain LongtermGain Yes, we can make subclassing here.The subclasses ShorttermGain and LongtermGain may share certain attriubutes like number of shares, quantity of stocks (Gain has a position object), etc.,Advantages:Avoid code duplicationDisadvantages:",Portfolio:Responsbilities: Maintain the positions of stocksCalculate the earnings.Collaborators:PositionStock,"class Exam2 def method_missing(meth, *args)     puts #{meth}, is not defined end e.Exam2.new  end",eat() method of Animal is overridden in eat() method of Horseeat(String s) is the overloaded version of eat(),"Horse eating hayThe reference variable a is of type Animal. So a search is performed from Animal class. It tries to find a eat method with matching signature. Once it finds that, it scans the subclass Horse to get more specific version of eat method.( note signature of Animal and Horse should match)  Once it finds that eat(), it calls.","Yes, we can prevent the methods from being overridden by using final keyword in Java. prefix final for both of these methods.",EO,XABCO,ZDAO,L[Y] = YDBEOL[Q] = QXYZDABCEO,Strategy patternThere are common situations when classes differ only in their behavior. For this cases is a good idea to isolate the algorithms in separate classes in order to have the ability to select different algorithms at runtime. How Strategy pattern works:Takes an algorithm from its host and encapsulates it into a separate class.An object and its behavior are separated and put into two classes.This allows the algorithm to be switched at any time.The algorithm/behavior encapsulated in its own class is called a strategy,Advantages:Eliminates large conditional statementsEasier to keep track of different behavior because they are in different classes.A variety of implementations for the same behavior.Disadvantages:Increases the number of objectsAll algorithms use the same interface."Ramachandran, Srikanth",This would really simplify the process of selecting the correct method because all java has to do is try to match the parameters with the methods in the class of the same name . If it finds a close match it can imminently call that. This can help making the process compile time instead of deciding at run time using dynamic typing.,It does not matter. There should be a proper balance for between the strengths and weaknesses of the conditions as each of them have very important effects on the correctness and performance of the system. Strong can cause low performance and weak can cause errors. Hence a balance is needed.,Aggregations,Principle of least astonishment,Yo-yo effect,Liskovs substitution principle.,"makeOneShapeFromAnother(Shape inShape, String type) does not accept proper parameters. This is because the values of inShape and type need not match each other.",This can cause serious issues as the correctness and robustness of the program is lost with spurious values. Also it is security risk.,We can make an API for each of the child classes.static private Shape makeOneShapeFromAnother(Rect inShape)static private Shape makeOneShapeFromAnother(Circle inShape)static private Shape makeOneShapeFromAnother(Cylinder inShape),"Yes, We need to use the class Object as the parent class to pass in the parameters.",portfolioearningsdividendmanager,purchase pricecurrent priceThey are just values that keep changing with time. They need not be made into classes. Instead they can be made as instance variables in a class.,1. Manager - handles different portfolios.2 . A portfolio  - handles many stocks.,quantity of stocks,"Stock(super)- earnings , loss , gain","Portfolio - Responsibility - Addstock , calculategainCollaborators - Stock , earnings","class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined    class_eval %Q?          def #{meth}              puts Hello from +#{meth}          end        ?    eval (meth.id2name)  endends = Exam2.news.syhello", public void eat() in Horse class overrides the same method in Animal class.public void eat(String s) is an overloads the eat() method in the same class as they differ only by parameters.,It will print Horse eating hay due to dynamic binding in java. At runtime the class of the object is checked. We find that the Horse class has the API eat() hence that is called.,All we have to do is add the keyword final before the methods. Thus they can never be overridden by any of Horse's child classes.,EO,XABCO,ZADO,QXYZADBCO,This is strategy pattern in action. Here the print function is chosen based on the user setting the print_operation value.,Advantage : As the strategies are split it the code is cleaner and readable.Disadvantage : The client gets exposed to the implementation details as he has to know what behavior is achieved with what value."Ranade, Ashwin",,,,,,,,,,,,,,,,,,,,,,,,,,"Ranjan, Rahul",,,,,,,,,,,,,,,,,,,,,,,,,,"Rao, Sandeep",,Having Stronger pre-conditions is always better because we can make sure we have a well formed system before executing the code.Also we need to make sure we have strong post conditions as they validate the code for the well being by using class invariants and other mechanisms.But there is also a condition which specifies that we should Under no circumstances shall the body of a routine ever test for the routine?s precondition. This is according to Meyer's principle .Hence we should always have the strong post conditions and sometimes we can have weaker pre-conditions which depends on the case.,Active Records,Principle of Least Surprise,Yo Yo effect,Liskov Substitution Principle,The code is not adherent to OO style of programming. The basic reason for this is that we could have used  Subtype polymorphism or interface feature and other OO techniques to remove the conditional programming in the code. Using such conditions is not a good idea to check for Type.Also we can see that there is a lot of code duplication being done in terms of Math.sqrt () being called in every block of the conditional. This is another problem.,"It is bad to violate this rule because, it is not very flexible to add newer classes in future or remove some unrequired classes. Example: In future if we need trapezium in the code, it is messy to modify the code. Also, it increase code duplication. Also, we will require Type variable to be checked now, as it can contain invalid values to yield Runtime errors.","Style guidelines suggest the use of Subclassing which is  a neat way of solving the problem. We define an SuperClass called Polygon which can be implemented by Circle, Rectangle and Cylinder classes.The Superclass provides a method called calcArea which is declared as follows:Shape calcArea (Shape inShape){  ...}Every polygon class which inherits this interface can use the method to calculate params and also area.public void calcArea(Shape circleShape){for(Polygon poly : polygons) {poly.calcArea(circleShape);}}This eliminates the code duplication. We can also override the super class calcArea method. Another neat way to do this is using Interfaces instead of Superclasses.","Yes, it can be written even if they are system-defined classes. But usually if the classes are very old and have been there for a very long time, it is undesirable to change the class definitions.Also, changing system classes might be harmful in other ways because of functional cohesion among the subclasses and super classes. We have to have the complete knowledge of the system classes and its super classes to change the code without any unpredictable results.",PortfolioManagerPortfolioStockShareDividendRecord are some of the important classes with different key abstractions of the system.,Earnings or the final profit is one of the classes which cannot be named as Earnings because of the naming convention.,A portfolio is a set of stock positions. This is a whole part relationship.  Many stock positions together form a portfolio.,,"There is an opportunity for sub classing in this design/ We can use Price/Quote as the Super class. Purchase price, Current price and other cost related classes can be derived from this Price Class.Advantages:All of them have similar characteristics and behavior, hence we can reduce the code duplication. Easy maintainability of code and also readability.Easy to calculate profit loss and other statements by using message passing among objects,Disadvantages:It becomes complex to manipulate them once subclassing is used because of Liskov principle.",Colloborators:1. PortfolioManager2. Stock3. RecordResponsibilites:1. Calculate the current value of all stocks2. Calculate the total dividend to be paid for all stocks.,"class Exam2   def method_missing(meth, *args)                        //using the concept of method aliasing , by finding the method name and printing output    puts  #{meth} is not defined        define_method(is_#{meth}?) do                   //Using the concept of define_method to define a new instance method which will be running from the next execution instance.             puts  Hello from #{meth}         end  endendexam = Exam2.newexam.prep;","In the horse class, a. Method:  public void eat() which is method 1 overrides method 0.b. Method: public void eat(String s) which is method 2 overloads method 0.","The output of the following function will be:Generic animal eating genericallyThis is because, Animal a = new Horse() ; creates a new object of type Horse and assigns it to Animal. The function called is with respect to animal, hence search space is limited to Animal class.",Yes the horse class have an overriding implementation and also we have to use Animal calss for declaring it.,"[E, A,O]","[X, A, B, C,O]","[Z,D,A,O]",,The pattern used in Strategy pattern. We have 2 different algorithm implementations available here which are printing Success and printing Failure. Hence the strategy pattern dynamically chooses the right instance and performs the correct print() operation.,"Advantage: We can later add any type of new print() algorithms by creating a new class without having to mess with your IpPrint class, and without having to override methods which can be messy to maintain and debug.      Also it helps us in segregating the algorithms and hence increases code maintainability and readability.Disadvantage:It has a disdvantage of catching lesser errors at compile time.   Also, we need to use Generics to facilitate use of strategy pattern which make the code a little complex.""Samyuktha Potluri, Sri",If Java used the actual types of arguments to decide which of several methods to execute then we could directly go the method by looking at the actual type of arguments without having to search the inheritace hierarchy. This would save time.,We would like the pre-condition to be as weak as possible as it describes the input requirements of the routine in as general a way as possible. That is it can accept a variety of inputs without filtering away most of them. We would like the post-condition to be as strong as possible as it describes the properties of the output of the routine in as narrowly as possible. This means the strong post conditions help the client in giving the closest to the best outputs as much as possible.,Active Record,Principle of Least Astonishment.,Dynamic Binding.,Subtype or Subtype Polymorphism.,It is including all the code to calculate the different outshapes in the same method. It violates the principle that a method should do only one thing and do it well.It is also checking the type of the object being recieved which is not a good idea.It also has a very long method name.,It is bad to violate this rule because everytime a new case is to be added we should modify the existing method which is not a right way to code.,"The style guidelines say that the makeOneShapeFromAnother should delegate the function calls to other methods which convert the correcpoding inshapes to outshapes.  So, for each shape rectangle, circle etc, each should have its own method to calculate the outshape and this basic method should only send calls to the corresponding methods.an example signature for Circle method would bepublic shape circle(int area, int x, int y)","If they were system defined classes, we could use a generic interface which they would all implement in order for them to have their own implementations of their respective outshape method which calculates the cooresponding outpts.",PortfolioDividendEarningsTotalReturn,position is not a class as it is a quantity and it can be expressed as integerloss is not a class as it can be seen directly from gain and we don't have to define it as a class,Portfolio contains a set of stock positions. Here portfolio is a whole and stock position is  a part of the whole.earnings also can be a whole which is composed of  gain + interest + dividends),total return and total earnings are kind of ambiguous in the requirements. It is not menetiond anywhere about how total return is calculated and so this term can as well be substituted with total earnings so eliminate redundance and confusion.,Portfolio and Positions could be sublassed as all the common attributes of the stocks can be put in the base class and only those particular to the child class can be included into the child class.,"Know stock positions- Position class can be used as collaboratorcalculate earnings- Dividends, interest can be collaborators.","class Exam2def method_missing(meth,*args)  str=#{meth}puts #{meth} is not defined.  eval %{  def #{meth}puts Hello from #{meth}end      }endende=Exam2.newe.sayHelloe.sayHello",In the Horse class the public void eat()  (method 1) overrides the eat method(method 0) in its parent class as they have the same signature and are in two different classes. public void eat(String s) (method 2) overloads the public void eat()(method 1) in the Horse class as they are in the same class but have different signatures.,Horse eating hay is the output of the program. It prints this as the eat method in the Hourse class overrides the eat method in the base class of Horse and during dynamic execution the actual class of the object to which the message is passed is considered which is Horse class for the object a.,Yes we can modify the Horse class to prevent both eat methods from being overriden but declaring them as final methods. The signatures will then be  public final void eat() and  public final void eat(String s).,EO,XABCO,ZADO,QXYZADBCEO,The pattern used here is Strategy. Strategy pattern is used when we want to execute something depending on the situation. These are immediately formed on a request being recieved and discarded as soon as the request is serviced.,The advantage of using this pattern is that depeding on the suucess or failure we can execute whichever version of the print() function we want to. The disadvantage is that in case of similar implementations in both cases we will violate the DRY principle. And Strategies also need to be instantiated before executing and discarded immediately."Sasidharan, Suneet",,,,,,,,,,,,,,,,,,,,,,,,,,"Singh, Anand",,,,,,,,,,,,,,,,,,,,,,,,,,"Sridhar, Srinath",There would be no ambiguity when using the compare. and the compiler can easily determine which compare method to call. We could have one generic compa,It does not matter. For a given precondition / postcondition. If the caller makes sure that the pre condition is satisfied before the function call then it can be sure that the post condition will hold good. Strengthening the precondition or weakening the post condition results in a similar formula,Active Record,Principle of least astonishment (PLA),yo-yo effect,Liskov Substitution Principle (LSP),High coupling. The makeOneShapeFromAnother function handles all the functionality for conversion from the given shape to every other shape. If one of the conversion routines change then this class has to updated. Also this function can become very complicated.,It quickly becomes difficult to mange a code with high coupling. Also the code becomes extremely long and inefficient,"We could ideally define an interface like the followingpublic inteface Converter{public Shape convert(Shape inShape)}the  function could take in this Converter object as paramter and just do the followingmakeOneShapeFromAnother(Shape inShape, Converter c)Shape outShape = c.convert(inShape);return outShape.We could implement converters for each of the different shapes.CircleConverter implements Converter to convert an object into circle",If suppose Circle Rectangle and Cylinder. all inherit from some common abstract class say shape which implements the getPosX() getPosY() etc methods then we could use the same principle.If on the other hand all of them are inherited from some common class say object then it would not be a good idea to write the conversion this way.,PortfolioRecordShare Position,purchase price and current price should not be implemented as classes. These are attributes of a given stock. These depend on the marketSimilarly gain and loss should not be implemented as classes. These are attributes of a stock and are calculated based on current and purchase prices.,There is an aggregation relationship between Portfolio and Position.A portfolio is a collection of positions.,The terms Position and stock are used ambiguously.,"Bonds and shares can be sub classes of Position. Both contain a quantity, current and purchase price etc. But both calculate the tax separately.",1. Calculate earnings - Position2.,class Exam2  @@mname  def method_missing(method)    str = method.id2name    @@mname = str    puts #{str} not defined    class<<self      class_eval %Q?          def #{@@mname}              puts hello from #{@@mname}          end      ?    end  endend,Method 1 overrides method 0Method 2 overloads method 1,The program prints Horse eating hay This is because of dynamic method invocation. When the method is called the actual type of the object is used to find a match. In this case since object a actually represents a horse the eat() method of horse class is called.,We can prevent this by making both the eat methods final. Declaring a method final makes sure that any class that inherits from Horse cannot override the eat() or eat(String s) method.,EO,XABCO,ZDAO,QXYZDABCEO,Command Pattern,Advantages   It lets us run asynchronous commands in the background.Disadvantages  We might end up with a lot of small commands and it could become unmanageable.`"Sudarshan Kalkere Sudarshan Smitha, Kalkere","If Java used actual types of arguments to decide which of the methods to execute, then we would not need to include a comparator object for each type. This would save a lot of code.","(a) Weak preconditions are better because strong preconditions involve that we trust the client running our program to adhere to the conditions, and the liability is on them which makes our code not very efficient. If we have handled all the various scenarios then irrespective of what the client's inputs are our code should not break. That is we should handle various conditions to let the client know when a certain condition is not satisfied.(b) Strong post conditions will achieve correctness because once we have legitimate preconditions that are satisfied, we should be able to deliver with the right post condition.",Mutators,The principle of least astonishment,Yo-yo effect,Liskov's Substitution principle,It violates that rule that each class should have one responsibility and do it well.,Violating this rule can create cumbersome code with lot of bugs in it. It may not function well and fulfill all its responsibilities.,"We can have a method to convert it to each shape, eg-Shape convertToCircle(int x, int y)Shape convertToRectangle(int x, int y)etc.We could call these methods by switching on type.","Yes, we could still rewrite the code to follow the style guidelines.","Portfolio, Shares, Record, Earnings","1. Purchase price - This is not a key abstraction, it is one of the prices that the stock position holds at a given time. It is not something that can be reused. It is just a numeric value.2. Value - This is not a key abstraction because it can computed using the attributes of the stock position at a given time. These attributes are purchase value and current value of which current value keeps changing. There is no reason to include value in the system since it can be computed.",Portfolio consists of shares (stock options),"The Portfolio is defined as a set of stock positions and the positions is stated to be a number (quantity).The portfolio is also defined to contain shares, where shares are added or removed.The portfolio is a key abstraction, which a set of stocks or shares where the shares are added or removed depending on whether is bought or sold.","Record can be a subclass of Shares. This is because Record is nothing but a stock option which is sold.Advantage of this is that there can reuse of code, and there is no repitition of data. Disadvantage is that the record does not need to perform a lot of actions or contain data that stock options contains because it's now sld and just held there for historical purposes.",Responibilities                                                                  Collaborators-----------------------                                                                ---------------------1. Fetch the current price of a stock                                   Stock2. Calculate earnings of a stock                                         Earnings,"class Exam2    def method_missing(name, *args)     puts #{name} is not defined        endend",method 1 overrides method 0method 2 overloads method 0,"Output: Horse eating hayDuring runtime, it checks for the class of which the object a is, which is Horse, so it calls the eat() method that Horse has implemented.","Yes, it can be modified as follows:public final void eat() { //method 1        	System.out.println(Horse eating hay );     }public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }",,,,,The design pattern used is Command Pattern.Command pattern involves encapsulating an action to be stored and used later.,"Command pattern is useful because we can have general components built which can used be used later and by all, for example in the above code, the print command prints irrespective of who is calling it.The command implements everything by itself, without sending anything to the receiver of the command.""Surani, Mihir",If Java used the actual types of arguments to decide which of several methods to execute then we could define different compare() methods for different data types and could call it from the sort method with our data type simply as Object and the compiler would know exactly which compare method to call.,"Preconditions that are as weak as possible, or strong preconditions. The hypothesis should always be weak.The precondition binds the client. It defines the conditions under which a call to the routine is legitimate. It is an obligation for the Client and a benefit for the supplier. Whereas, the postcondition binds the supplier. It defines the conditions that must be ensured by the routine on return. It is an obligation for the supplier and a benefit for the client.",Active Record,Principle of Least Astonishment,Yo-Yo effect,Liskov Substitution Principle,"This class tests the class of an object to decide which method to call, to generate the required shape type.",,"We should use polymorphism here. We can have some abstract class, called AbstractShape and this class can have a method shape which will be overloaded in different ways. Like for circle",Resp: Manages stock positionsCol: Stock PositionsResp: CAlccu,"Portfolio, Stock, Position, Dividend","gain/loss - is not a key abstraction, because it can be calculated from current price and previous price.rate (of increase) - is not a key abstraction, because it is just a numeric value.","Bonds is a part, Stock is a whole",,Does not make sense to define it here,,"class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined    eval %{def #{meth}               puts Hello from #{meth}             end}    self.method(meth).call  endende = Exam2.newe.sayHelloe.sayHello",eat() overrides the eat() method of Animal as it has the same signature and thus it hides the earlier method.eat(String s) overloads the eat() method.,"OUTPUT: Horse eating haya is defined as an animal, thus when the method eat() is call the compiler will look for the function n the Animal class. Then, when it finds the eat() method in the animal class, since a really is a Horse, the compiler will perform dynamic binding to look for any overridden method with the same signature in class Horse and will find the overridden method.",We can prevent the both the Horse class methods (method 1 and method 2) from being overridden by declaring both of them as final. Final methods cannot be overridden by any other class.,EO,XABCO,ZDAO,QXYZDABCEO,Delegation,Advantage: Delegation is a way of extending and reusing a class by writing another class with additional functionality that uses instances of the original class to provide the original functionality.Disadvantage:The main disadvantage is that it requires to write all the code for delegating all the necessary requests to the implementing class. Like our interface here does not have any code."Sureswaran, Vignesh",,"Strong preconditions.This is because one has to check on a tight leash what goes inside a function so as to avoid any funny behavior from the function.Strong postconditions.This is because, one has to make sure the output pertains to the preconditions that are agreed upon. And a strong one means less chances of violation.",Abstraction,Principle of least Astonishment,Yo-Yo problem,Liskov substitution principle,One method does one thing and does it well.,The code becomes obfuscated to follow and it will make the reader wonder what is happening in that particular if/else block. This is against P.L.A,The inner code in each of the if/else block should be replaced by its own function callassignCircle()assignRectange()assignCylinder(),"Yes, we can still rewrite the code to follow the style guidelines.",PortfolioStockQuantity/PositionBond,currentPrice and purchasePrice can be easily expressed as a float/Double. So there is no need to make it a class.A record doesnt have to be a class since it could be calculated on the fly and can be calculated by a formula.,Portfolio and Stock. Stock can exist without being inside a portfolio.,Portfolio and Portfolio manager are used interchangeably.Portfolio describes the key abstraction.,stock and bond can inherit from the same parent as they have some members in common.No it doesnt make sense to define subclass relationship as there is not much to save from subclassing as you need to tailor more than one features acc to the subclass.advantage : Possibly achieve code reuse.Disadvantage:Need to redefine a number of methods as they are diff btw stock and bond.,Collaborator : Quantity/Position class.,class Exam2def method_missing(meth)eval %{def #{meth}         puts  Hello from #{meth}        end        self.#{meth}       }endend,eat() in Horse overrides the eat() in Animaleat(String s) overloads the eat() in Horse,"Horse eating hay - is the outputThis is printed because eat(void) in Animal is being overridden by the eat(void) in Horse. and so, When dynamic binding occurs, eat(void) in Horse is found to be a more specific match.",One could declare both the functions 'final'final void eat() and final void eat(String s),E,XABC,ZDA,QXYZDABCE,"Strategy pattern. In this pattern, the algorithm to be used to execute the method 'print()' is determined at runtime based on the type of object passed into the setPrintoperation(). This is achieved by using interfaces.","Advantage : One could potentially have any number of variants for a particular function call. This makes the application flexible.Disadvantage:It would increase the number of objects in the system i.e one per implementation,""Vangala, Swamy","This problems in Java can be simplified by using DELEGATION. Delegation has many advantages over inheritance as we call the method, which we require using the instance of that particular class. Though we have an Comparator INTERFACE it can go wrong when we arguments are of not same type.Hence delegation is better in addition to Interface.",To achieve correctness we need Strong preconditions and weak Post conditions hence from the above options it isa) Strong PreconditionsWhen we have Strong preconditions this ensures that the caller(Client) satisfies all the prerequisites so that it wont results in any error(failure of the Supplier functionality) .Thereby we dont have to worry much about the postconditions as it satisfies all the conditions.However sometimes checking preconditions becomes more complicated and time consuming.,DataTypes.,Principle of Least Astonishment -PLA,Yo-Yo effect.,Liskov substitution principle.,"Th method name itself defined wrong, it should be static private  Shape_makeOneShapeFromAnother . And even the methods names inside it to assign values to variable are not understood easily.",Because it confuses the programmer as it is not readable and buggy.,"Even method names inside are not readable i,e not understood easily.They can be renamed like,inShape.getXPos(); --->shapeAttributes.getXPos()inShape.getYPos();---->shapeAttributes.getYPos()","No,we dont need to rewrite it.It is a way of code reuse.","portfolio,shares,position,value,earning","sahres,position","shares -->gains,loss",purcahse price and current price,"shares calss with subclasess of earning calculator,postion classes as subclasses.","Portiflios respaonisbilities -- getting shares,getting rates,colloborators are shares,value",class Exam2  def sample   'sample' endende = Exam2.newe.sayHello # => NoMethodErrordef e.sayHello 'Hello from sayHello'ende.sayHello # => 'Hello from sayHello'Hence the above code  tells how Singleton classes are used to implement instance specific behavior in Ruby.,In Horse Classpublic void eat() ---> overrides public void eat() method of Animal Classpublic void eat(String s) ---> overloads public void eat() method of Animal Class,Horse h = new Horse();Animal a = new Horse();1)  h.eat() gives  Horse eating hay as output since it has overridden the eat method of Animal Class.2) h.eat(grass) gives Horse eating  grass as output since it has overloaded the eat method of Animal Class.3) a.eat() gives Generic animal eating generically as output since we use delegation here to call the eat method Animal through its instance.,by making it as same method with assertions,EO,XABCO,ZDAO,QXYZDABCEO,"The design pattern implemented here is an Adapter pattern,also known as the Wrapper Pattern, which enables classes with incompatible interfaces to work together, by providing the users with its interface",Advantages:Wrappers used to adopt 3rd parties libraries and frameworks - most of the applications using third party libraries use adapters as a middle layer between the application and the 3rd party library to decouple the application from the library. If another library has to be used only an adapter for the new library is required without having to change the application code.Disadvantages:It has a problem when the objects use delegation."Wang, Fan",,,,,,,,,,,,,,,,,,,,,,,,,,"Wang, Yalin",,,,,,,,,,,,,,,,,,,,,,,,,,"Xie, Haosen",,,,,,,,,,,,,,,,,,,,,,,,,,"Xu, Shuang",,,,,,,,,,,,,,,,,,,,,,,,,,"Xue, Yao","When the actual types of arguments is used to decide the method to execute, we can simply send the arguments as generic type, then programming all the sort methods in the style of overloading. Then when the arguments came in, system will check the actual type, and send them to the right method. Then we don't need to have different method names and we don't need to know the type of the arguments when we send them.","(a) stronger precondition(b) weaker postcondition.because when the precondition is extremely strong, say, False. Then anything could happen as output and it wouldn't be the fault of the code itself. When the Postcondition is extremely weak, say, True, then no matter what you do in the code, it will always pass the post condition.",,the least astonishment principle,yo-yo effect,Liskov substitution principle,"code should be concise(readable) and reusable.in this case, calculation of three different shapes should be defined as methods instead of laying codes in complex if else structure.",It is hard for others to read and understand the code. it looks too complicated. The three different methods can actually defined as methods and just use the method in the if else structure. it wasted code and prevented the calculation functions being reused in the future.,I should define the different calculation cases as methods. then use the method names in the if..else structure.mekeRect(shape inShape)makeCircle(shape InShape)makeCylind(shape InShape),"Yes I can, when the three shapes are different classes, it is even easier, I can have a single method name makeShape() and overloaded it with three different type of input arguments, then we don't even need the if..else structure.","stock holdings, portfolio, position(holding), record, bond holdings",current value and quantity.they are just numerical values,A portfolio has several positions(bonds or stocks) as its parts.,"record.When the sold deal has a positive gain, system should calculate the tax due to the gain and add it to the record. But when the deal was a loss, the way to generate record is changed, most of the taxes shouldn't be calculated.","The bond holding and stock holding could be subclass of position(holding).it has some sense of using subclass here.advantage: It is easier to manage the stocks and bonds. Because both of them have similar variables. Like current price, purchased price and gain.disadvantage: When there are other types of investments involved in this portfolio which has little similarity with the bonds and stocks, using it could complicate the case",responsibilities:1.know the holdings(bonds or stocks) it has.2.calculate the total earnings.collaborators:for 1. position(or bond and stock)for 2. position(or bond and stock) and record,class Exams    def method_missing(method)        str = method.id2name        puts str + is not defined    end        Object.class_eval(add instance methods)do        class &amp;lt;&amp;lt; self        def attribute_accessor( instance_variables )            instance_variables.each do |instance_variable|            class_eval %Q?                def #{instance_variable}                    puts Hello from + instance_variable                end            ?            end        endendend,eat() in class Horse overrides the eat() in class Animal.eat(String s) in Horse overloads the eat() in class Horse.,Animal a = new Animal()a.eat()output: Generic animal eating genericallybecause it is the only method in Animal.Horse b = new Horse()b.eat()output: Horse eating hay because no argument is sent.String m = meatb.eat(m)output Horse eating meatbecause a String was sent and method eat() in Horse is advocated.,I can make both methods private to protect them.,EO,AO+BO+CO,DO+AO,X(AO+BO+CO) +Y(DO+BO+EO) +Z(DO+AO),it is a adapter pattern. It defines a interface of Iprint first then have both Success and Failure implement it. An adapter allows classes to work together without incompatible interfaces.,"Advantage:  Adapter can make different classes work together and prevent incompatible interface problem. In this case, it can make sure both success and Failure will do the same operation print().Disadvantage: In this particular case, the operation is too simple that incorporating a adapter could be waste of time. Because it can be easily solved with a if else structure without extra code.""Ying, Xichun",,,,,,,,,,,,,,,,,,,,,,,,,,"Zhang, Huijun",We can just define different methods based on parameters' types in Sort class.,"(a)strong(b)weakIf the preconditions are strong, it reduced the cases that the methods excute. So as weak conditions.",Dynamic Method Invocation,Principle of Least Astonishment,Inheritance,Liskov principle,"1. Name is too long makeOneShapeFromAnother. 2. Circle, Rect, Cylinder are different objects.","1. It makes code not easy to understand, waste of time and space.2. The methods defined are not easy to use.","Only if these two classes are immutable, or one cannot be the subclass of another.",No. vialate the principle of least astonishment. These methods may behaves differently according to the chages.,"portfolio, position, price,  earnings","1. gain or loss are not classes because they are just numeric values. 2. purchase price, or current price are not classes because they are particuler type of price.",whole relationship : portfolio contains positions.,"record: 1. record of many stocks selling and buying operations. 2. record of earnings, gains, loss","short/long term positions can be subclass of position. Yes. Ad:  short term and long term positions can use different methods to calculate the tax.Dis: When short term becomes long term position, the problem appears, because one subclass cannot change its type to another.","R                                          C1. Calculate earnings:   Earnings2. Buy stocks:                  Position, Price",class Exam2eval %{  if (method  is not defined)     puts #{attribute_name} is not defined.  else    def #{attribute_name}      puts Hello from @#{attribute_name}  end }end,method 1 overrides eat() method in Animal class. method 2 overload eat() method in Animal class because the parameter type are different.,"Generic animal eating generically  #this is the Animal class outputHorse eating hay  #this is Horse class output of overriding #superclass's methodHorse eating grass  #this is Horse class output of overloading #superclass's method, grass is input string",public -> private,EO,XABCO,ZDAO,QXYZDABCEO,strategy pattern,Ad: Encapsulating the algorithm in separate Strategy classes lets you vary the algorithm independently of its context.Dis:Strategy pattern increases the number of objects in an application."Davis, Andrew","The problem would be simplified because the algorithm chooser (strategy pattern if applicable) could guarantee the proper implementation of a sorting method for the given type. If the sorting method didn't exist, the compiler would generate an error (instead of something like a not implemented error). Generics helped to mitigate this issue.ran out of time","Weak preconditions put strain on the supplier to make sure the contract is fulfilled, while strong preconditions put strain on the client to make sure the contract is fulfilled (and vice versa for postconditions).Correctness is achieved when the contract is fulfilled in a manner of least surprise, regardless of how that contract is carried. Thus, as long as the pre- and post-conditions are satisfied and the contract fulfilled, correctness will be achieved.",Active record,Principle of least surprise,Nesting (?),Liskov Substitution Principle,"Not sure on exact name, but big if-else if-else block violates good style; it is violating the principle of polymorphism/inheritance because it is using a not robust check on the shape type in the form of check a string.Also, a cylinder is a 3d shape while a circle and rectangle are 2d. It is difficult to compare these shapes outright.","It is bad to violate this rule because it opens up the possibility for violating the principle of least astonishment (and also might break a contract), especially because it is creating a zero-height cylinder.",Something like:static T createShapeFromArea<Shape T>(double Area)class Rectangle extends Shape {...}class Circle extends Shape {...}class Cylinder extends Shape {...},"Yes, the code could still be re-written provided that they all inherit from the Shape base class (and the 2d/3d behavior was better defined).","- Portfolio- Holding (stock or bond)- Transaction (record line item)- Position (group of holdings)Only chose three because a portfolio holds many stocks or bonds (holdings) and a history of transactions. The rest can be calculated from metadata (fields) of the stocks, bonds, or transactions.","/Purchase price/ is not a key abstraction because it can simply be represented as a field of a stock or bond and does not inherit from any other abstraction./Tax/ or /tax liability/ is not a key abstraction because it is a calculated value based on purchase price, current price, and how long it was held.",I believe this is represented as a filled diamond in a UML diagram:One aggregation relationship is the holdings (positions) in the current portfolio. This would be something like where one ore more stocks or bonds are purchased at different times so they have similar properties but different purchase prices. Similar shares (for example in a single company) could be grouped to see what the value of that holding is as a whole.,"This is an ambiguity in regards to the use of stock, bond, holding, shares, and position. There a couple ways these collaborators could intract and be constructed, such as simply having an array of holdings, or having positions that contain holdings, or positions that inherit from stocks or bonds.","There could be a Stock class and a Bond class that inherit from a abstract Holding class, with the difference being that bonds pay out interest instead of dividends.Conceivably, there could also be an abstraction of the Transaction class where there could be different classes like Purchase, Sell, or Tax Payment for example.","Like any portfolio, its main responsibility would be to hold/store its contents (in this case stocks and bonds). Another responsibility it would have is to aggregate its contents and perform calculations. A third responsibility would be to maintain a record of transactions.Collaborators with this class would be the Transaction history class and the stocks/bonds themselves (in an aggregate relationship as an abstract Holding class).","class Exam2endclass Exam2  def method_missing(meth,*args)    puts #{meth} is not defined	eval %{def #{meth}	         puts Hello from #{meth}		   end		   self.#{meth}}  endende = Exam2.newe.sayHelloe.sayHello",eat() in Horse overrides eat() in Animal.eat(String) in Horse overloads eat() in Horse.,The program outputs Horse eating hay  due to dynamic method invocation (the Horse instance gets called despite it being declared of type Animal).,"Inheritance can be stopped by using the final keyword:public class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }     public final void eat() { //method 1        	System.out.println(Horse eating hay );     }     public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}","= E + merge(O,O)= EO","= X + merge(AO, BO, CO, ABC)= X + ABCO= XABCO","= Z + merge(DO, AO, DA)= ZDAO","= Q + merge(XABCO, YDBEO, ZDAO)= Q + XYZABCDEO= QXYZABCDEO(* assumes previous parts are correct)","This appears to be an implementation of the Command pattern. A generic command for printing control is defined as the IPrint interface, while various commands can be defined that implement this interface. This is similar to how a word processor might invoke a printer driver -- whatever the active printer is, call the print() method and the driver (Success or Failure class) takes over from there.","One advantage is that the client does not need to know anything of the implementation details of the method it is calling. However, this comes at the expense of the overall interface requiring a high degree of extensibility and robustness to cover all cases. in the cases of a printer, it needs to be able to handle all kinds of error messages, media types, color reproduction parameters, etc.""Ezen TA, Aysu",,,,,,,,,,,,,,,,,,,,,,,,,,"Gallinger, Nathaniel",,,,,,,,,,,,,,,,,,,,,,,,,,"Heiss, Karl","The sorting problem would be much easier because the compiler would just use the object type to determine the comparable method to sort with.  Instead, we have pass a Comparitor of the correct type.","If is preferable to have weak preconditions and strong postconditions.  This is because by doing this, we tighten the scope and functionality of the function to the point that there are no conditions that are not covered.  If preconditions are strengthened too much, or the postconditions weakened too much, the function will no longer be correct.",ActiveRecord,The Principle of Least Astonishment,The yo-yo effect,The Liskov Substitution Principle,It violates the maintainability of the code.,Violating this rule means it is difficult to maintain as the code grows and changes.,There should be a separate object for each of the shape types and those objects should be called from the makeOneShapeFromAnother method.,,portfoliorecordpositionbond,dividend: Is an integer number of stocks and thus cannot be an abstraction.current price: It is the same as the value of the stock.,A portfolio contains a set of Positions each of which contains a stock and quantity.,"Gain, it is used to refer to the change in stock price as well as a change in the overall position, which has a long term and short term.  The key abstraction would be in the position.",A bond should inherit from a stock because it provides all of the functions of a stock with some extra functionality.  This makes sense for us.,Responsibilities:Knows stock quantitiesKnows stocksCollaborators:Stock,Object.class_eval do  class << self    def method_missing(method)      str = method.id2name      puts #{str} is not defined.      class_eval %Q?        def #{str}(*args)          puts Hello from #{str}        end      ?    end  endend,The eat() method from Horse overrides the eat() method from Animal.  The eat(String s) method from Horse overloads the eat() method from Horse and Animal.,"Output: Generic animal eating genericallyThis is because the Horse instance 'a' is cast as an Animal.  As such, it calls the eat() method from the Animal class.","As long as the instance is being called as a Horse, the final keyword can be used to prevent these methods from being overridden.",LO,XABCO,ZDAO,X = XABCOY = YDBEOZ =  ZDAOQXYZDABCEO,"This is a strategy pattern pattern.  The IPrint interface allows differing strategies, in this case success and failure, to be passed to PerformOperation.",The strategy pattern means that you have to follow the interface defined by the inherited class."Iyengar, Balaji","The implementation of the comparator interface ends up being generic with 'Object' types being used and several sub-types such as StringComparator and IntegerCompartor extending the base comparator. If Java used the actual types of arguments to decide which of the several methods to execute then you could have have multiple overloaded sort functions with different incoming argument types and the runtime could easily pick the right one, thus simplifying the code.","In general with defensive programming you should have :1. preconditions that are as weak as possible.2. postconditions that are as strong as possible.Because errors are most certainly going to happen and illegal inpur is going to be given to methods, so making sure that the method can defend against such input by doing something explicit is helpful to the user of those methods.  Stong post-conditions are easy to enforce since the current method has all the state it needs to check and enforce this.However, if you programmed to a contract and use Meyer's s non-redundancy principle:  then we wouldn't do any checking on the precondition. In general making preconditions weak and post-conditions strong is the way to go.",Scaffolding,Principle of least astonishment,Yo-Yo effect.,Liskov substitution principle,"It breaks both abstraction and encapsulation. the code to determine the object The functionality to determine the type of the object is repeated and should be abstracted away in a separate function. Also, it would help if  the calculations were in  separate classes (circle/rectangle)","it exposes the functionality of different types, i.e., Rectangle/Circle/etc in the main program. This is bad for multiple reasons:a. we dont expose the function provided by each of these types in a standard API, this results in repeating code. For e.g. each place we want to find the radius of the circle, we would have to repeat the code:      radius = Math.sqrt(area / math.PI); b. It doesnt allow us to change this functionality without touching the main program. If the formula for the radius of the circle changed, then we would have to find all the places in the code and make that change. This results in buggy and inelegant code.","Shape fill_values(type, radius, width, height) { if (type.equals(circle)) {     radius = Math.sqrt(area / math.PI);     outShape = new Circle(x, y, radius); // Assign a circle   }   else if (type.equals(rectangle)) {     width = height Math.sqrt(area);     outShape = new Rect(x, y, width, height); // Assign a rectangle   }   else {     radius = Math.sqrt(area / (Math.PI * 3));     height = radius / 2;     outShape = new Cylinder(x, y, 0, radius, height);//Assign cylinder   }return outShape;}","Yes, you can. Each of these classes would implement the functions to fill out the radius/width/height etc and you would create the corresponding outShape.",portfolioearningspositionearnings.gain.,"Shares: they are essentially holdings and you could have holdings of two kinds: shares/ bonds. So 'holdings' are the key abstraction and shares and bonds are the two sub-types.Purchase price: is not a key abstraction, it is more of an attribute of a single stock/bond.",A Portfolio contains 'shares' and 'bonds' and has an aggregation relationship.,It seems like 'earnings' is used ambiguously to mean several things:gaininterestdividend The 'earnings' usage represents the key abstraction.,"Stocks and bonds can be implemented as sub-types of type 'holdings'A lot of the attributes between stocks and bonds are common, for e.g., purchase price, current price, number bought (position) .Similarly we have different kinds of 'earnings', i.e., gain, interest, dividend and they have common attributes as well.The advantage of sub-classing here is that the common functionality can be moved to the parent class, there by leading to code re-use and cleaner code.The disadvantage could be tight coupling between the parent and the sub-classes. So, if we needed a new kind of 'earning' then it might be difficult to implement that.","responsibility-1: track the total number and type of stocks/bondscollaborator-1: the 'position' class maintains this data and can provide it to the portfolio class. responsibility-2: output the total earnings of the portfoliocollaborator-2:  the 'position' class, the 'holding's' class and the 'earnings' class to provide us with all the information needed.","static undefined_method = true;  def method_missing(meth, *args)   if (undefined_method) {     puts #{meth} is not defined      puts Hello from #{meth}     undefined_method = false;  } else {    puts Hello from #{meth} } }   end",Override:  public void eat() { //method 1 This overrides the method in the 'Animal' class.Overload     public void eat(String s) { //method 2This overloads the eat function in the Horse class.,Output:Horse eating hay It prints this because the runtime environments determines that the receiver class if of type 'Horse' and finds an overriding implementation  of the function eat in the 'Horse' class and executes that function.,"Yes, you can do so by using the 'final' modifier in the function definition: public final void eat() { //method 1  public final  void eat(String s) { //method 2",,,,,"This is the command pattern in use. A program needs to issue requests to objects.  The code that is doing the requesting doesn?t know what the receiver will be, or what operation will be requested. In general the receiver is the one who knows how to perform the operations needed, the purpose of the command being to help the client to delegate its request quickly and to make sure the command ends up where it should.In this case the print_operation could be of type Failure or Success and the requesting code doesn't know this. The print_operation object executes the print() command.",Advantages:The main advantage of the command design pattern is that it decouples the object that invokes the operation from the one that know how to perform it. Disadvantages:1. It can result in lot of  command classes that can clutter up a design.2. some implementations of the Command design pattern might need to include parts for supporting undo and redo of actions. In order to do that a mechanism to obtain past states of the Receiver object is needed."Alexander, Sterling","If this were the case, Java would support multiple inheritance, which would mean that method calls would search the inheritance tree for any class that was mixed into the subclass and call the appropriate method (provided the inheritance tree is properly constructed through the design).","Weak preconditions and strong postconditions.  The stronger the precondition, the more likely the method call will fail in some way, a relaxed precondition allows for the method to run (not always correctly).  A strong postcondition gives a reliable answer or value in return.  Depending on the values passed in, you will get some values passed out.  They may or may not be correct, but the method has satisfied the contract and taken what was given and provided a result.  If the preconditions are met (and the values passed in make sense) then the results should be valid.",Object Relational Model,Principle of Least Surprise,Inheritance Tree,Liskov Substitution Principle,The type of shape is detected using if statements instead of polymorphism,"Each time a new shape is added to the system, this class will have to be modified to handle the new shape.","Derive subclasses for each new Shape and the proper methods necessary for each subclass.  If we assume that get and set position is defined in the superclass, then we would need the following methods in the subclasses defined above:For Rectangle getWidth(), getHeight(), setWidth(x), setHeight(x)for Circle, getRadius(), setRadius(x)For Cylinder, getRadius(), getHeight(), setRadius(x), setHeight(x)","If they all have as a direct common ancestor the class Object, we would be able to write some code that would take advantage of polymorphism, however if they each had a different common ancestor this would not be possible.","Portfolio, Position, Shares, Record","Purchase Price -- This is an attribute of a stock or bondTotal Return -- This is a calculated value based on attributes of the stock or bond.  Since the purchase and sale price are recorded, this is a calculated value.",Portfolio can own many positions,Position is used as both a quantity of shares and also a time length that each was held for.,"Stocks and Bonds share common information, but Bonds pay interest.  If a superclass of Holdings is created, stocks and bonds can be subclassed from this superclass.  The advantage is that common attributes (price, etc) could be put in the superclass.  The disadvantage is that if a newer type of investment was added to the system, it would inherit all aspects of the new Holding superclass, which may or may not be appropriate.",Portfolio Responsibilities Create Position -- collaborator -- position classRemove Position -- no collaborator,class Exam2  def method_missing (*args)    puts args.to_s +  is not defined    eval %{def args.to_s.to_sym      puts Hello from + args.to_s      end}      end    end,Eat from Animal is overridden by eat() in Horse.Eat is also overloaded by eat(String s) in Horse,"Horse eating hay  -- The output is generated from the overridden function, there is no argument passed to the call, so eat() from Horse is called and executed.","yes, use the keyword final in the method declaration.public final void eat()public final void eat(String s)",EO,XABCO,ZDAO,XYZDABECO,Command pattern - The PerformOperation class fetches the appropriate operations from the implementations of IPrint interface that is passed in and performs the appropriate commands based on the values of the defined in the implementation of the interface.,"Advantage -- The successes and failures can be collected and printed all at onceDisadvantage -- If the program has an unusual termination, the program might not print all the messages before it terminates.""Alexander, William",,,,,,,,,,,,,,,,,,,,,,,,,,"Alford, Adam",,"Ideally we would like both conditions to be strong, but It depends on the situation and how a class' methods are going to be used.  If we have a subclass S of class C, for every method with identical signatures: the preconditions for C?s method are no weaker than the preconditions for S?s method, and the postconditions for C?s method are no stronger than the postconditions for S?s method.",,Principle of least astonishment,Reflection,Liskov substitution principle,Factor out duplicated code.,Related to DRY,,,"portfolio, position, shares, record",Short term and long term are not key abstractions because they are independent to the system and do not need to be represented within it. A loss is just a type of gain,Portfolio - Stock,A portfolio is a set of stock positions. Each position is a quantity of a particular stock.  A quantity is expressed as a certain number of shares.It's unclear if a position is a stock position or a quantity of a particular stock or a share.I believe the correct use is that a position is a certain number of shares.,"Bonds and Stocks are both types of shares, they both have the same attributes just a different way of calculating returns.The Bonds and Stocks subclasses could inherent all functions and attributes of the shares class and only have to implement a method to calculate their returns.  One advantage would be DRY.","RES: addStock(), removeStock()COLL: stock, stock & record",def method_missing(meth)    puts #{meth} is not defined.    createMethod(meth)    meth()enddef createMethod(meth)  Exam2.class_eval do        define_method :meth do           puts Hello from #{meth}         end    endend,"Class Horse eat() method overrides the Animal eat() method, while eat(String s) overloads it.",Horse eating haythe Java environment does not look in the declared class of a Instead it looks in the actual class of the object referred to by a (Horse),"Yes, use the final modifier on the method declaration, which means ?this is the final implementation of this method?, the end of its inheritance hierarchy.",EO,XABCO,ZDAO,QXYZABCDE,Adapter Pattern,"Satisfies the DRY principle,If the class changes the adapter no longer works.""Evans, Owen",,"Preconditions that are as weak as possible, and postconditions that are as strong as possible is better. This is because we want the input to be as broad as possible, but correctness for the output to be as broad as possible.",Object relational mapping,The Principle of Least Astonishment,multiple inheritance,Liskov Substitution Principle,"This should be an instance method for the Shape class, not a class method.",,You should rewrite it so that there isCircle.makeOneShapeFromAnother(String type)Rectangle.makeOneShapeFromAnother(String type)etc.,You cannot modify system classes in java.,stockbondpositionportfoliorecord,"Value: The value of a stock is a property of a stock but it is just a number, and thus does not merit its own class.Earnings: Earnings would be an instance method of the portfolio class used to calculate the total earnings (or loss) of a portfolio, but it would not be a class by itself.",A portfolio is an aggregation of positions.,"Gain is used ambiguously. It can refer to either the gain of an individual position, or the gain of the entire portfolio. The key abstratction is the gain of an individual position, because the tax is calculated differently based on the type of position that it is.",A stock and a bond could each be a subclass of position.,Responsibility 1:Keep track of the set of positions held within the portfolio.Collborator 1: positionResponsibility 2:Calculate total earnings across all positions within the portfolioCollaborator 2:position,"class Exam2 def method_missing (meth, *args)   puts #{meth} not defined endende = Exam2.newe.sayHelloe.sayHello","eat() from Horse override eat() from Animal,eat(String s) overloads the eat() method.","The output is:Horse eating hay The reason is that it first matches the eat() method from the declared type and then looks for the overriding method in the subclass (that must have the same signature). Method 1, in class Horse, has the same signature s Method 0, in class Animal, so the method is overridden.",You can declare them 'final' which will prevent them from being overridden.,EO,XABCO,ZDAO,QXYZADBCEO,This is a Command pattern.,One advantage: The code doing requesting the requesting does not have to know what the reciever will be or the operation requested.One disadvantage: The code doing the requesting cannot specify a specific operatoin."Ezen TA, Aysu",,,,,,,,,,,,,,,,,,,,,,,,,,"Godbole, Rahul","A Comparator interface would need to be used first in Java, that would provide a template for the compare method.The different types that need to be compared will implement their version of the comparator method, that would take 2 objects as arguments. Now, depending on the types of arguments that are passed to the method, the corresponding compare method is called. Eventually, the sorting problem will make use of the compare methods to sort the underlying data type.","Preconditions that are strong and postconditions that are as weak as possible will help achieve correctness.The reason being that a strong precondition ensures that a program is correct regardless of what it does. Also, weakening the postcondition can help make the program achieve correctness too.",ActiveRecord,Principle of Least astonishment,Code reuse,Liskov substitution principle,"Designing for change, separation of responsibility.","If there is a new shape that gets created, several lines of code would need to be added here. Also, the actual work of calculating these should be delegated to the actual shape objects.","The calculation of width, height, etc. should be delegated to the specific objects.","Yes, references to these classes could be maintained in the class.",PortfolioPositionShareRecord,"gain - this is a property of a set of stocks, not a key abstraction.interest - this is a part of the earnings, so can be easily used as a primitive type in the bond/share class.","earnings is an aggregation of gain, interest and dividends","Stock is a term that is used ambiguously in the requirements. A set of stocks is used as a portfolio. A quantity of stock - position. Also, quantity of stock is represented by shares. Also, bonds are similar to stocks in a few properties such as purchase price, current price.","Bond can be a subclass of Stock. The advantage of subclassing:1. Bond inherits the purchase price, current price, gain properties.2. Avoids code duplication3. Methods that operate on properties are inherited.Disadvantage: Instead of dividend, bonds pay interest. So, a way of overriding the returns for a bond needs to be done. Dividend cannot be defined as a property for the base class as it would have no meaning for bond.",Responsibilities:1. calculateEarnings2. calculateReturnsCollaborators:1. Record2. Share,"def method_missing(meth, *args)  puts #{meth} is not defined.enddefine_method :sayHello do  puts Hello from sayHelloend",method1 overrides method0.method2 overloads method1.,"Output: Horse eating hay.Reason: Java uses the actual type of the class instead of what it was declared with to decide which method to call at runtime. In this case, although a is declared as Animal type, the constructor of Horse class is used, hence the actual class is Horse type.",Yes. By adding the final keyword to the class definition.public final void eat() { //method 1 ....public final void eat(String s) { //method 2,EO,XABCO,ZDAO,QXYZO,Delegation pattern. The PerformOperation class delegates the task of printing to one of the classes implementing the IPrint interface.,Advantage:This is a flexible way of achieving a task as interfaces can be implemented in different ways.Disadvantage:Disadvantage:Amount of code can be large and inefficency."Gregory, Tracy","It wouldn't require the extra step of identifying which type of Object you are trying to compare.  When we had the comparison step pulled out using a simple Compartor function with different overloaded methods for each type, that would have enough.  The system would know which method to use based on the type.  There would be no need for the interface and the different implementations of Comparator.",a) weakest preconditionb) strongest postconditionThese are the tightest bounds for correctness.,ActiveRecord,Principle of Least Astonishment,Yo-Yo Effect,Liskov Substitution Principle,A method should do only one thing and do it well.,Makes it difficult to read and maintain code.,Use an interface (or abstract methods) for common behaviors.public Interface getShape   with public outShape createShape(Object)public class CircleShape implements getShape  with public outShape createShape(Object)public class RectangleShape implements getShape  with public outShape createShape(Object)public class CylinderShape implements getShape  with public outShape createShape(Object),"Yes, using delegation (such as in the Stack example given in class)",,,,,,,class Exam2  def method_missing(method)    puts #{method} is not defined        eval %{def #{method}            puts Hello from #{method}          end}          endende = Exam2.newe.sayHelloe.sayHello,method 1 overrides method 0method 2 overloads method 1,"Horse eating hayDynamic method invocation.  The compiler looks at the declared type of the object being sent the message, but at runtime the overriden method is chosen using the actual type of the object being sent the message",declare both methods finalpublic final void eat()public final void eat (String s),EO,XABCO,ZDAO,QXYZDABCEO,Strategy,(D)The decision which strategy to use can change meaning your code would need to change if additional decision points were to be considered.  i.e doesn't respond well to change(A) Flexbility and reuse of code"Grover, Krishan",,,,,,,,,,,,,,,,,,,,,,,,,,"Jones, Quintina",,"b)  Strong preconditions will require more code through out the program to check for valid arguments and error handling prior to calling each method to deal with invalid data.  Strong postconditions will require validating code in a single method that can be called repeateldy, though it would still require error handling outside of the method to handle invalid arguments.",,Readability,Simplicity,Liskov Substitution Principle,A method should do only one thing and do it well,It makes testing complicated.,Put the duplicated code with a single method that can be used.CircleRectangeleCylinder,"Yes, you can use the existing classes and make a wrapper tailored to your needs.",PortfolioHolding - Subclasses:StockHolding and BondHoldingStockPosition,"Record - because even though it is a noun it is merely a container to store gain and tax due when a stock is sold, and doesn't really require any methods and would be better suited being an attribute of the PortfolioPurchase Price - though it is a noun it is specific to each stock or bond and remains constant so it is better suited being an attribute of the Holding class, thus the StockHolding and BondHolding class by default.",A Stock Position is part of a portfolio.,Stock,"StockHolding and BondHolding could be subclasses of a superclass called Holding, because bonds are similar to stocks other than one caveat where bonds pay interest in lieu of dividends.  It makes sense because Stocks and Bonds are extremely similar except for one aspect, so an advantage would be code reuse, and I'm unsure of a valid disadvantage of subclassing.",Responsibilities:1. Knows the number of stocks2. Knows the number of bondsCollaborator:StockHoldingBondHoldingStockPosition,"class Exam2   def method_missing(meth, *args)     puts #{meth} is not defined.     define :meth        puts Hello from #{meth}     end   endend","The method 1 has overriden method 0, and method 2 has overloaded method 1","Horse Eating hay, because a is an Animal object instantiated as a Horse object.  So, due to dynamic binding, it starts with the eat() method in the Animal class, but then looks for a more specific method and ultimately calls the eat() in the horse class.","Yes, you can use the final keyword.",EO,XABCO,ZDAO,QXYZDABCEO,Strategy design pattern,Advantage: This pattern helps when you need to choosean algorithm for a task depending on some ?parameter? of the situation."Ma, Jia","In JAVA, the sorting algorithm takes a Comparator parameter to allow use to tell the program how to compare the elements. We can first create a Comparator interface, then create all the different comparator class, such as string compator, int comparator, to implements this Comparator interface. Then once the program runs, it will look at the type of object that is sorting, and find the right method to compare the object and sort.","precondition should be as week as possible and postcondition should be as strong as possible. For example, {x >= 9} x = x + 5 {x >= 13}. In this case, if we make the postcondition stronger, {x >= 14}, then it will have more correctness. However, if we make the preconditon stronger, let's say x>= 10, then 9 will be ommited for this formula, which is not good. So we want to make the precondtion weaker.",Database Migration,Principal of least astonishment,,Liskov Substitution Principal,"Every time you add a new shape, you need to modify this Shape class. Also not all the shapes have radius or width or height","the more you modify the code, the more bugs you will introduce. Also, when using a shape like Rectangle, the radius variable will never be modified","We can use inheritance or interface to fix this. For example, we can create a Shape interface, and create 3 subclasses, Cylinder, Circle, and Rectangle to implement that interface. each subclass have different outShape method implementation, and the program can figure what shape is it by checking the constructor of the shape. Then it will automatically find the right outShape of the right shape.","nope, we cannot modified these classes to have it implements Shape interface.","Stock, PortfolioManager, Record, StatisticsCalculation","Interest and price should not be used as key abstraction because they are primitive variable like Integer. Earning should not be used as key abstraction because it is just a sum of gain, interest and dividends. Even though this number will be affected by these 3 variables, but since it has no member functions, it will be pointless to use it as abstraction.",Earning = gain + interest + dividends,"loss loss can mean many different things, for example, weight loss, or disadvantage.But in this case, it means the negative value of difference between the value of the stock when it was bought and its current value","Bonds should be a subclass of Stock because it can be treated like Stock. they have a purchase price, current price, and gain (or loss). But instead of dividends, they pay interest.  Advantage: reuse code for purchase price, current price, Disadvantage:","Responsibility: calculate earning -> collaborator: StatisticsCalculation, StockResponsibility: generate record -> collaborator: Record, Stock","class Exam2  def method_missing(func, *args)    puts #{func} is not defined    puts Hello from sayHello.    eval %{def #{func}               puts Hello from sayHello.           end}  endend e = Exam2.newe.sayHelloe.sayHello",method 2 overloads method 1method 1 overrides method 0,"Horse eating hay Because of dynamic method invocation, method 1 overrides method 0. a is declared as Animal, so it first goes to the eat() in Animal, then due to dynamic method invocation, it goes to eat() in Horse",add the key final to those 2 methods. public final void eat() public final void eat(String s)final is used to prevent overridden,EO,"X + L[A] + L[B] +L[C] = X+ merge (AO,BO,CO) = XABCO","Z + L[D] + L[A] = Z + merge(DO, AO) = ZDAO","first, L[Y] = Y + merge(DO, BO, EO)= YDBEOThen L[Q] = Q + merge (XABCO, YDBEO, ZDAO) = QXYZDABCEO","Strategy design pattern. This pattern first needs a interface, in this case it will be IPrint, Then in PerformOperation, depending on the IPrint value (success or fail), it will choose to print success operation or fail operation.","Advantage: it reuses code, and more operation can be added easily in the futureDisadvantage: operation cannot be chosen at run time. Also, it will increases of number of objects created.""Malmgren, Graham",,strong precondtions and weak postconditions.the setup needs to be correct to call. but what is done afterward is none of my business.,reflection,principle of least astonishment,yo-yo effect,inheritance,"it is ambigious, there should be a different method for each shape conversion..",the caller of the method does not know if their shape is supported.,create different methods for each shapestatic private Circle toCircle(Shape inShape);static private Rectangle toRectagle(Shape inShape);static private Cylinder toCylinder(Shape inShape);,"yes, because they are static.",portfoliopositionshares,=purchase_price==current_price=,portfolio   has positions    has shares,"portfolioWhen a stock is bought/sold, it is added/removed to the portfolio. -> should really be added/removed to the positions in the portfolioThe key abstraction: A portfolio is a set of stock positions",stock could be a superclass for bond.,"Calculates the earnings (collaborators are the positions and shares, which should have their own methods for calcuatin earnings based on the purchase_price and current_price)Calculate total return (collaborators return on the positions and shares (they should have their own methods))","class Exam2    def method_missing(method)         puts #{method} is not defined      define_method(method.to_sym, -> { puts Hello from #{method} })  end     ende = Exam2.newe.sayHelloe.sayHello",Horse.eat() overrides Animal.eat(),"<output>Horse eating hay </output>although the object is an animal, it was declared as a Horse and the Horse eat method overrides the Animal.eat method",Yes.public final void eat();public final void eat(String s);--Added the final keyword to the method declaration,EO,XABCO,ZDAO,QXYZDABCEO,strategy pattern.,this permits the IPrint method to be determined at runtime rather than at compile time."Manring, Michael",It would help because then the sorting algorithm could focus on the arguments first and rule out a lot of methods that do not use those arguments.,"Preconditions definitely need to be strong because if they are not specified, then the caller of a method with weak preconditions could leave out crucial information that the method may need. This could result in wrong information or even hosing up the system in a worst case. Postconditions should also be strictly defined so that the method caller knows what to expect back. Java implements this well with the way it requires the coder to define what type will be returned from a particular method.",,principle of least astonishment,delegation,Liskov substitution principle,This is breaking the rule of decomposition.,"It is bad to violate this rule because it can make the code unreadable and also, more so in this case, makes it hard for the code to be reused.","This problem can be fixed by breaking the functionality of this out into three methods, one for each shape that is being made.static private makeCircle(Shape inshape)static private makeRectangle(Shape inshape)static private makeCylinder(Shape inshape)","Yes, those definitions would not affect this because the methods are named differently than what would be defined in those classes.","portfolio, record, share, dividend",'purchase price' is not a key abstraction because it is a property of a stock and should be defined as such.'earnings' is not a key abstraction because it is a calculation of many properties and should be defined as a method of a portfolio.,A portfolio is the aggregate of stocks.,,"A bond could be defined as a subclass of a stock. As stated, the only difference between the two is what is payed out (stocks pay out dividends, bonds pay out interest). Code reuse would be a great advantage here since the only thing you would have to change in the bond class would be the methods and/or properties that determine how it pays out.","'addStock' would be a responsibility since it holds a set of stocks positions and would collaborate with the Stock class.'calculateEarnings' would be a responsibility as well and would collaborate with the Record, Stock and Bond classes.","class Exam2    def method_missing(sym, *aras , &blk)        puts #{sym} is not defined.        self.class.send :define_method, sym do            puts Hello from #{sym}        end    endend",Method 1 eat() in the Horse class is an override of the function.Method 2 eat(String s) is an overload of the function.,This program would print Horse eating hay  because the variable a is an instance of the Horse class and so it would use its eat() function.,You would simply add the 'final' keyword to the method definition.public final void eat()andpublic final void eat(String s),EO,XABCO,ZDAO,QXYZABCDEO,The design pattern in use here is the Adapter Pattern. The PerformOperation class acts as an adapter between all IPrint classes and grants a programmer the ability to use the print operation of any of them.,This makes it so that one could call the printMethod() and get the printed value of any IPrint object and not have to know exactly what method needs to be called."Mason, Scott",,,,,,,,,,,,,,,,,,,,,,,,,,"Mohan, Prasanth",,,,,,,,,,,,,,,,,,,,,,,,,,"Patel, Dhaval",Java only lets you extend one class so you can have one overridden method from superclass also Java lets you have method with same name but different signature so then selecting a method java uses this comparison techniques to figure out correct method.,Strong precondition and weak postconditions. The reason for this is that if you have weak precondition it will be false most of the time and the program will not have tight boundaries. Same with the post condition if its stronger along with strong precondition than it will effect the outcome of the program,Model. which are generated using scaffolds.,command pattern,Inheritance,Liskov substituion,Polymorphism,It is bad to violate this rule because the above shown code is hard to maintain. If you want to add a new shape you have to make changes to many places. Additionally it has repetitive code.,"1) Create an interface class Shape1 that has a method called convertshape that takes in two parameters shape and string2) Create three new classes Circle, Rectangle and Cylinder that implement interface shape1 and method convertshape.3) This classes should",Yes. making the interface and then passing the shapes to the interface to directly call the classes.,"portfolio, Gain, stock, bond, Loss, short term, long term",1) Stock Price is not a key abstraction as its can be represented as a double variable2) Tax is not a key abstraction as it is just a calculation.3) Dividend,"Gain, Short term gain, Long term gain",Gain as possitive gain is used as profit and negative gain is used as loss for calculations,Short term gain and long term gain can be subclass of Gain. Short term loss and long term loss can be subclass of Loss.,"1) Adding stock to the portfolio     Collaborator: stock, bonds2) Calculate total earnings  Collaborator: Gain, Loss","class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined.    f = Exam2.new    f.class_eval do      define_method :meth  do         puts Hello from #{meth}      end    end  endend",1) eat() in horse class overrides eat() in animal class.2) eat(String s) in horse overloads eat() in horse,Output: Horse eating hayReason: The eat() in animal is overridden by eat() in horse so when calling eat() it goes to the animal class to lock the method signature. But when scanning everything it finds the new eat() in horse and uses that method during run time.,Yes by making the method static final other classes can extend the horse class but cannot override it.,EO,XABCO,ZDAO,QXYZDABCEO,Adapter pattern. In the code above the interface IPrint is initialized and used for printing things. Classes success and failure implements this IPrint interface and the print method. So when the print method is called on the interface it redirects to the correct print method depending on if the print was successful or failed.,one advantage for using this pattern is to have a capability for classes to work together with incompatible interfaces. One disadvantage is it makes it hard to debug as we don't know which method it will call."Scheve, Scott",,,,,,,,,,,,,,,,,,,,,,,,,,"Sevin, Olivier","the most specific fit of two compared objects would be used, so there would be no need to typecast","Precondtions and postconditions should both Preconditions should be strong so that the method designer can focus exclusively on dealing with relevant arguments. If the programmer has to start each method with a lot of conditional statements to filter out the junk, he is more likely to make a mistake and it will be harder to maintain correctness. Also, the client will not know they are giving bad input if the preconditionsPostconditions should be as weak as possible .",reflection,Principle of least astonishment,yoyo problem,Liskov substitution principle,Single responsibility principle. Each method should do something and do it well,This method is trying to do too much and accept too wide a range of parameters.,The method should delegate responsibilities to other methods. makeCircle(Shape inShape),If they all had,"portfolio, stock, bond, record","share, it is simply an integer manager, it shouldn't be implemented because its responsibility is just  a method of the portfolio",portfolio is an aggregation of stocks and bonds,position. It is used for both,"stock and bond. Having bond subclass stock would help not duplicate code, and allow a portfolio object to treat them as the same type to simplify its code. However it is not good O-O style to do this because a bond is not a stock. If they both implement or subclass a FinancialAsset class they will still maintain advantages while maintaining good style.","(assuming stocks and bonds now implement financialasset):add an asset to the portfolio, stocks or bondscalculate the earnings, stocks or bonds","class Exam2   def method_missing(id) class Exam2   def method_missing id, *args      name = id.id2name       puts #{name} is not defined.      eval %{def #{id} *args               puts Hello from #{name}            end}  endend",Horse.eat() overrides Animal.eat()Horse.eat(String s) overloads Animal.eat(),Horse eating hayIt prints this out because the first place java looks for a method is in the subclass,add final keyword to both classesie. public final void protected eat,EO,AOBC,DOA,XAOBCYDEZO,Strategy,It allows you to customize which action you want to take in an elegant way rather than with if's and thens. A disadvantage is there are more objects and the programmer choosing which strategy to use has to know which are available and what they do."Sharma, Sonal",,,,,,,,,,,,,,,,,,,,,,,,,,"Valenti, Aldo",,it would be better to have weak preconditions and  strong postconditions to eliminate any ambiguity for both the caller and the callee over the use and behavior of a statement.,Active-record pattern,Least Astonishment Principle,yo-yo effect,Liskov substitution principle,open-close principle,because you have to touch the source code of a class to extend it,"I would create a Shape class that holds the common data/behavior among Circle, Rectangle and Cylinder. Circle, Rectangle and Cylinder would subclass Shape. If needed I would create adapter classes to adapt a generic Shape to a particular one (Circle, Rectangle and Cylinder)",,portfolio managerportfolioholdingstockbondposition,Quantity does not need to be implemented because it can be a primitive type.Earnings does not need to be implemented because it's a computed value.,A portfolio is a set of positions.,"gainWhen a stock is sold, it is removed from the portfolio, and a record is generated that records the gain and calculates the tax due on the gain.A stock may also pay a dividend. A dividend is not taxed like a gain, but it is used in calculating a stocks total return.Bonds in the portfolio manager can be treated like stocks; they have a purchase price, current price, and gain (or loss). But instead of dividends, they pay interest.The portfolio manager should calculate the total earnings (which is defined as gain + interest + dividends) for a portfolio, and use this to calculate the total return (average percentage earnings per year).","A bond could be a subclass of stock because bonds have a purchase price, current price, and gain (or loss) like stocks but instead of dividends, they pay interest.Instead of subclassing I would create an interface, let's say 'Holding' implemented by both bond and stock so that both bond and stock can still inherit from another class if needed. Other types of holdings could be added in the future. If all the types of holdings share part of the implementation I would factor out that common implementation into a common parent class for all the holdings.","Portfolio knows about positions -> collaborator : positionCompute earnings -> collaborator : stock, bond","class Exam2  def method_missing(meth, *args)      puts #{meth} is not defined.       eval %{def sayHello                 puts Hello from sayHello                end}      self.sayHello  endende = Exam2.newe.sayHelloe.sayHello",public void eat() overrides the same method from the superclass.public void eat(String s) overloads public void eat() in the Horse class,Horse eating hay because Java uses the actual runtime class (Horse) not the declared type (Animal),make both eat methods in Horse final.,EO,XABCO,ZDAO,QXYZDABCEO,"the strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.",advantage: allow to easily choose the algorithm to execute at runtime saving potentially long if/else statements.disadvantage: more classes/code need to be written"Vartika Singh, Fnu","public class Comparator{public int compare(String o1, String o2){return s1.compareTo(s2);}public int compare(Integer o1, Integer o2){int i1 = o1.intValue();int i2 = o2.intValue();return i1 ? i2;}...compare(?) methods for other types of data}","According to Meyer  ?Zen and the art of software reliability: guaranteeing more by checking less.? so precondition should be as week as possible. It will  only harm if the tests to check it increase complexity. It depends on the kind of precondition, if its something that could be done easily then its recommended else not.",Active Records,Principle of Least Astonishment,yo - yo,Liskov Substitution Principle,Extensibility and Readability.,"The method is made static private. Hence only objects of that class will be able to access it. If we need more shapes then we will have to  modify this private method but according to the open closed principle software entities should be open for extension, but closed for modification, but it is not open from extension.","Create an interface shape and then implement it for different shapes.Interface Shape{convertToShape(Shape s)}Class Rectangle implements Shape{Rectangle convertToShape(Shape rect){}}void main(String args[]){Shape shape[]=new Shape[];shape[0]=new Rectangle();shape[1]=new Circle();for(i=0,shape.size >0;i++){ shape[i].convertToShape();}}","Yes even with system defined classes, I can still  write the code with a slight change. I can include the existing libraries and make the changes according to my needs. That ways I am following DRY and making my code specific to my needs also.","Portfolio, Stock, Record, PortfolioManager, Bond","Position, PurchasePrice, CurrentPrice because its a value","A portfolio is a set of stock positions, where portfolio is the whole and stock positions are part objects.","Bonds in the portfolio manager can be treated like stocks. Bonds and Stocks are used ambiguously in the requirements.Each stock has a purchase price and a current price. Bonds in the portfolio manager can be treated like stocks; they have a purchase price, current price, and gain (or loss)",Bond can inherit from Stock since all the instance methods i.e price are same with just one additional variable instead of dividends i.e. interest.,"Responsibilities:                                          Collaborators:To add/remove stock                                  Stock, RecordTo store the stock positions                         StockTo generate a record                                   Record","class Exam2def method_missing(meth, *args) puts #{meth} is not defined puts Hello from #{meth} eval %{ def #{meth}puts Hello from #{meth}end }endend",method 1 overrides method 0method 1 overloads method 2,Horse eating hay since a.eat is called and due to dynamic method invocation the eat in Horse class is called.,"Yes, by changing the signature since a method is overridden only when its signature is same as its super class.",E+merge(O)= EO,"X+merge(A,B,C,ABC)= XABC","Z+merge(A,D,AD)=ZAD","Q+merge(X,Y,Z,XYZ)=QXYZ","Command Pattern. There is an interface, IPrint which has a method print which is implemented by classes Success and Failure.","Advantage: The object need not know who the receiver is, , encapsulates single actionDisadvantage: don't know the receiver""Wilborne, Marvin",If java could use the argument types it could select the appropriate sort function.,A - weaker preconditions keep you from having to put excessive error trapping inside the function.B - strong post-conditions - ensure that the function/method/class behaves as expected with the inputs that it is given.,ORM - object-relational mapping,principle of least astonishment,IS-A relationship.  It should be clear what the code is a subclass of by implementing all the features of the parent object and possibly extending it.,Liskov Substitution Principle (LSP),"The shapes have inconsistent requirements for representation.  For example, width & height don't apply to a circle but to the rectangle.  Height applies to both cylinder and rectangle but does not apply to circle.",There are different data requirements for the different shapes.  Nothing prevents you from saving a radius with a rectangle object.,"A cylinder is an extension of a circle, so a function or class that represents 0 height cylinders (a circle, or a stack of circles who's height is 0) to any height of stacked circles(a cylinder).","Yes, you can.  You can use a function or formula approach to restate how a rectangle becomes a cylinder or a circle, just like the built in parts of the original function, taking as input the correct datatype/class for the object you're going to convert (input) and outputting the correct datatype/class for the output shape.",portfoliopositionrecordearnings,"purchase price - is not a key abstraction.  It is the price of  stock or bond purchased which is part of the position class.tax - tax due is not a a key abstraction since it is a calculated amount based on a variety of factors when selling shares in a position, including the long or short term nature of the position, the gain or loss and the dividends or interest received on the position.",a portfolio contains or owns the positions.,"position - a position is used to represent an ownership of a stock, but will also be used to represent the ownership of a bond since a bond can be treated like a stock.  Instead of dividends, like a stock may receive, bonds receive interest.  So here is another ambiguity of a position.  Shares of ownership of a stock or bond represent the key abstraction.","It makes sense for the portfolio to be the superclass over the other classes.  This way all the information for a specific portfolio are grouped in a relationship that makes it easier to deal with as an object.  It also allows the possibility of a client having multiple portfolios (which is done, since there are pretax portfolios and after tax portfolios, and there are objective based portfolios... growth or income, etc.).","responsibilities - add position, remove positioncollaborators - current share price, gain or loss, short or long term held, taxes due, record buy or sell",1.rescue NoMethodError  puts ,The first and second eat method does not override the animal eat method.  There are no overloads.,horse.eat() -> Generic animal eating generically.,"Probably so, but I don't have time to fill in the answer.","E+merge(O,O)=EO","X+merge(AO,BO,CO,AB,AC,BC)=XABCO","Z+merge(DO,AO,DA)=ZDAO","Q+merge(XAO,XBO,XCO,YDO,YBO,YEO,ZDO,ZAO,XY,YZ)=QXYZABCDEO",,"Aube, Jeremy","The sorting problem would be simplified because the sorting method for each object type could immediately assume that it's sorting objects of the same type. Instead, sorting methods have to do a lot of type conversion and handling exceptions when objects being sorted are not the expected type, which adds a lot of unnecessary weight to the method.","Neither is true. Correctness requires both strong preconditions and strong post conditions. When designing by contract, it should be very clear both what the method should expect and what results of the method should be.",Object-relational mapping,The principle of least astonishment,the yo-yo problem,Liskov Substitution Principle,polymorphism,"The class as-is will need to change every time a new shape is introduced. By using polymorphism, the concerns pertaining to specific shape types can be handled within the shape class instead.","You should use delegation to handle different shape types. In this case, we may also need some time of factory that can the shape attributes that all shapes shareoutShape = ShapeFactory.(inShape, type)ShapeFactory can then handle what do in each of the various cases and make the proper conversions.","No, if the system defines it, then they can no longer be considered subclasses of Shape, so a subclass of shape cannot be returned.",portfoliopositionrecordgain,loss is not a key abstraction because there is no reason to represent it in the system as this can be fully handled through gain.current price is not a key abstract because it is no longer needed once it has been used in calculating the gain.,portfolios contain positions,"gain contains information about a gain, so it's ambigious in the sense that it's simply the difference between the purchase value and current value, it can be a short term or long term gain, it calculates its own tax, and it's part of the earnings calculation. The key abstraction is when it's used to calculate tax since it it then thought of it terms of methods used on it.","shorterm and longterm could be subclasses of gain. This may make sense since tax could be calculated directly within the subclass, but then some of the attributes of gain might have to be made protected instead of private, which would decrease encapsulation.",Portfolio should manage positionsPortfolio should calculate annual rate of increase.Collaborators:Some class that provides current prices of stocksA class that provides various tax rates,class Exam2  def method_missing(m)    puts #{m} is not defined.    class.self.def_method(m) do      puts Hello from #{m}.    end  endend    end  endend,method 1 overrides method 0. method 2 overloads method 1 (since method 0 has already been overwritten).,Horse eating hayIt prints this because Animal's eat method has been overridden by the no argument eat method in Horse.,"Yes, if we added the keyword final, either to the class or to the methods, that would either prevent the class from being subclassed, or would prevent each method from being overridden.",EO,XAOBOCO,ZDOAO,QXAOBOCOYDOBOEOZDOAO,Decorator Pattern,"An advantage is that responsibilities can be delegated to the appropriate object without having to worry about the details of that operation. The downside is that it's not as clear what those objects may be doing, and in situations where one of them might throw an error or something like that, it will be more difficult to anticipate and recover from those errors.""Banz, Matthew",The sorting problem would be simplified because we could use a comparator object (like on page 67 of Skrien) where it has a method for each type of object that we would like to sort. We could merely call sort and pass in an array of whatever class we like. The sort method would simple call comparator.compare(data) and the right method would be called for the type of array passed in.,"There are two ways to look at it. The demanding way is that preconditions should be made strong. This makes the supplier able to not have to have extra logic to check the arguments and handle edge cases.Postconditions should be made weak as possible to allow for the maximum possible outputs.The tolerant way is that preconditions are weak and the method handles everything. This can be difficult, because there could be values for which the method doesn't know what to do.",Scaffolding,Principle of least astonishment,yo-yo problem,Liskov Substitution Principle,"A class, such as Shape, should encapsulate its data and have methods to act on that data. We should not need an external method to calculate the radius or other properties of the class.",This is bad because whatever class this method is in is tightly bound to the shape class (high coupling). There is no clear division of responsibility. Also whenever a new shape is added we have to come back to this method and add a new if statement.,Shape should define an abstract method such as clone that each derived class would provide its own implementation for. That way each class is responsible for cloning itself and it would have all the data it needs. We can also use polymorphism to clone any shape by calling its clone method.public Shape clone(),I could not do it how I have described above if that were the case.,"portfolio, record, stock","earnings - this should not be a class, but rather a decimal valueshares - this is just another term for stocks",portfolio owns collection of stocks,,,add/remove stocks - collaborator is stockremove -record,"class Exam2def method_missing(name, *args)",method 1 overrides method 2 overloads,The output is Horse eating hay .The declared type of 'a' is Animal but thanks to dynamic binding the eat method in Horse will be called because 'a' is actually a Horse.,Yes add the final modifier before each method declaration,EO,XABCO,ZDAO,QXYZDABCEO,Delgation,"One advantage is that the print_operation can be set dynamically at runtime.One disadvantage is that we must write code to get, set, and call the print_operation as opposed to just implementing IPrint.""He TA, Chun","If actual type is use, we can pass the call usingcompare(Object o1, Object o2)So we don't have to select whether it is stringCompare or integerCompare. The actual type will be selected at runtime like Ruby.",a) weak precondition as possible. Because that will ensure the parameters are valid to satisfy the postcondition.b) strong postconditions as possible. This will ensure the correctness of the procedure to satisfy the precondition.,ActiveRecord,Least astonishment.,Yo-yo effect,Liskov Substitution,A method should just do one thing and do it well.,It new shape is added we need to modify this method. This method will become long and unreadable unmaintainable.,Should make 3 seperate methods. Also each of this class should include in each of the shape classstatic private Circle makeCircleFromAnother(Shape inShape);static private Rect makeRectFromAnother(Shape inShape);static private Cylinder makeCylinderFromAnother(Shape inShape);,No. In Java you cannot add methods to system defined class. But if in Ruby you can do such modification.,"Portfolio, Position, Record, Dividend","Shares, this is just an integer should be an attribute of position.Tax, the rate is calculated by record and stored as part of the record.",Portfolio contains positions.,"record, it can be used for each sale, or purchase. Here a record is a sale record.","Bond position could be a subclass of Stock position. It doesn't really make sense to do so however, because even bond could be treat a s stock, it has interest attribute instead of dividend. The earning caculation also takes different parameters. Use subclass could resure some of the code, however it could be confusion when it comes to calculate earning.","Should be able to add record -> Record, PositionShould be able to calculate earning -> Position, Record","class Exam2def method_missing(meth, *args)    puts #{meth} is not defined    eval %{def #{meth}           puts Hello from #{meth}     end}endend",Horse's  eat() overrides Animal's eat().Horse's eat(String s) overloads its eat().,"Horse eating hayBecause a is a Horse object, it will use the eat() method of Horse.",You can make the method final. So a subclass cannot override it.final public void eat()final public void ear(String s),EO,XABCO,ZDAO,QXYZDABO,"Delegation. The PerformOperation class has a private IPrint object, it can delete to either Success of Failure class.","It implements DRY principle, doesn't repeat the comment print code. With interface it can passing in different type of subclass and have print() method implemented different way depends on the subtype without rewriting PerformOperation class. It's easy to update if we need to add new print operation. The amount of code needed is more than using inheritance, it's not as efficent.""Anirudh Kurakula, Bala","If Java used the actual types of arguments to decide what method to execute, we need not use the inheritance method. We can simple pass the Comparator object and find out which class is used. This was a problem earlier because the method is chosen based on value and not based on the actual type of arguments. Since in this scenario we use the actual types of arguments we are not in danger of error.",It is better to have weak precondition and  strong post condition to achieve better correctness. It does not mean that if either of them are the other way we cannot achieve program correctness. We can achieve it but it is always better to have weak precondition and strong post condition to avoid unnecessary ambiguity and leading to buggy code later. If the conditions are clear it makes more sense for some one to read and understand it. It also leads to better correctness.,Object Database,real world Classes,Interfaces,Inheritance,this is actually finding which shape it should be converted from the paramter  which is wrong.,in order to add another Class we need to change the method and while calling we need to use the nae of the class as the parameter to the function.,toCircle(Shape s)toCylinder(Shape s)toRect(Shape s),,PortfolioStockRecordDividend,purchase price purchase price is just the price for the stock and cannot be a class by itself.lossloss can be calculated by other class attributes. So cannot be Class,Share is the part of Portfolio,"position is used ambiguously. In one place it is defined as quantity of particular stockIn other place it is defined as Depending on how long the position was held, the gain may either be short term or long term.",Gain - LongTermGain ShortTermGainAdv: the subclasses can share the methods described in the Gin class. dis: An extra class Gain is required.,"respo: calculate_earnings, calculate_return, collo:PortfolioStock","class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined    eval %{        def #{meth}        puts Now method '#{meth}' is defined      end      }    end  endc = Exam2.newc.hic.hi",eat() method overrides eat() in the base class. eat(String s) overloads eat() method,Horse Eating HayThis is because the object declared method is Animal. So java works with respect to the declared object. So it looks into the Animal method first and finds eat() and then dynamic binding finds a specific method of same signature in the base class Horse and uses it.,we can declare the methods as final for them not be be over ridden.,EO,XABCO,ZDAO,QXYZDABCEO,"It is a command pattern.A program needs to issue requests to objects.  The code that is doing the requesting doesn?t know what the receiver will be, or what operation will be requested.",It need not write a different code for different class. It encapsulates a single action. Dis: Doe not know what the code is doing."Apsangi, Chandan","The method sort takes different class objects as arguments. So even if we define its header generically as:sort(Object [] A) and  pass it different objects such as String[], Integer[],etc.Because of Java's way of method resolution (based on the actual type of the object), there's no way to identify the correct method based only on the argument. If java were to behave like CLOS, then we could implement the interface sort(Object[] A) for different classes String,Integer,etc and  simply pass the curresponding object when making the call: sort(String[] A);sort(Integer[] A);","a) Preconditions should be as strong as possible. Because when we derive subclasses from this class, we can weaken the precondition, but not strengthen it. (From LSP). Hence the base class can keep it stringent, and let the derived class relax it as applicable.b) Post conditions should be as weak as possibleSimilar argument applies here. The post conditions for methods should be as relaxed as possible, so that when the subclasses strengthen them, and the user substitutes the subclass for the base class, he is not met with a surprise.",form_for,Principle of least astonishment,yo-yo effect,Liskov's substitution principle,It is not an instance method. Instead it is defined as a class method.,,,,PortfolioShareRecordPosition,gain and dividend are not a key abstractions because they represents a primitive type (A float) and it can be added as a member of a Portfolio class.short-term and long-term  they do not represent any real/tangible object. They cannot be translated to any programmable objects.,Position contains a set of Shares,Record,"Quantity can be defined as a subclass of Position, since they share is-a relationship.","Record - Used to maintain the individual earnings/losses , so that portfolio can compute it when requestedPosition - This represents the set of shares of a particular stock, hence Portfolio contains a set of these positions and needs to interact with them.","class Exam2     def method_missing(meth, *args)    puts args: #{args}     puts Sorry, I do not #{meth}    eval %{def #{meth}           puts Hello #{args[0]}    end}  endende = Exam2.newe.sayHello",method1 overrides method0 and method2 overloads it.,"It prints Horse eating hayBecause Animal a is referring to an object of type Horse. Hence when dynamic method invocation happens on eat(), it is called on the actual type (Horse) not on the declared type.","We can prevent the overloaded method2 from being overridden by declaring it as private. But we cannot make method1 private, since it is declared as public in the base class. The subclass cannot increase the access restriction of the base class.",EO,"L(A(O)) = AOL(X(A,B,C)) = X + MERGE(L(A) , L(B), L(C),ABC)                 = X + MERGE(AO,BO,CO,ABC)                 = X + ABCO                 = XABCO","L(D(O)) = DOL(Z(D,A)) = Z + MERGE(L(D), L(A),DA)              = Z + MERGE(DO,AO,DA)              = Z + DAO              = ZDAO","L(X(A,B,C)) = XABCOL(Y(D,B,E)) = Y + MERGE(DO,BO,EO,DBE) = YDBEOL(Z(D,A)) = Z + MERGE(DO,AO,DA) = ZDAOL(Q(X,Y,Z)) = Q + MERGE(L(X) ,L(Y),L(Z),XYZ)                 = Q + MERGE(XABCO,YDBEO,ZDAO,XYZ)                 = Q + XYZDABCEO",Here Strategy pattern is used. First we setPrintOperation by passing either success or failure class objects. Then we getPrintOperation and call print() on it whenever we need that message to be printed.,"Arjun, Vineeta",,,,,,,,,,,,,,,,,,,,,,,,,,"Asok Nair, Arjun",,,,,,,,,,,,,,,,,,,,,,,,,,"Balasubramanian, Aravind","If we use actual types of arguments to decide, the compiler can identify the method based on the arguments passed. If there are no methods that match the parameters, the compiler will throw a method mismatch error.","a) Stronger Preconditions: If the goal is to achieve correct output, it is necessary to give the precondition as strong as possible. This ensures that the statement is executed with the best possible input for the code to do what it is supposed to do. It removes unpredictability.b) Sronger Postconditions: To ensure that the code has actually done what it is expected to do, the output should match the postcondition. This makes it logical to make the postcondition as strong as possible.",Active Record,Principle of Least Astonishment,yo-yo effect,LSP- Liskov Substitution Principle,The method has lots of code that does different work. And there is code duplication. We need to factor out duplicate code.,"Makes the code less scalable. New implementations, say for rhombus cannot be added to this code without further duplicating.","We should just identify the difference in the implementation and create a method for it.public outShape(String str), based on circle, cylinder or rect, the outshape can be calculated",It is ok to rewrite the code for system defined classes. But we should ensure that the implementation does not impact other methods that could use these classes.,"portfolio, quantity, value, record",purchase price and current price. As they represent different uses of some price.total return- it is just a number.,A portfolio holds a quantity of the stock. Thus it owns a part of the stock.,loss. as it is just the opposite of a gain. It is going to just represent a negative gain.,"Stock and Bonds can be used as subclasses of portfolio. There are several common attributes between stock and bonds except that bonds pay interest instead of dividends. They can inherit all common attributes like purchase price, current price and gain and provide their own implementations of dividends or interest. The advantage is that we do not have to redefine code for common attributes and just use what is existing. One possible disadvantage could be that the code might get unmaintainable. Changes is common attributes could affect the implementations in subclasses.","Responsibility: Calculate total earningscollaborators: gain, bonds and stockResponsibility: Calculate gain or lossCollaborator: value","class Exam2   def sayHello(str)       puts Hello from sayHello   end    def method_missing(meth, *args)      puts #{meth} not defined      str = meth.id2name      sayHello(str)   endend",eat() method overrideseat(String s) method overloads,Output: Horse eating hayExplanation: Horse's eat() method is called as the method invocation results in looking into the animal class and then going down the hierarchy to the horse's class to identify the more specialized method and that specialized method is used.,"Once a class inherits from the base class, all methods that it contains will definitely override the base class's methods. To prevent overriding, define different method names. Or we should not make the class Horse inherit from Animal class.",EO,XABCO,ZDAO,QXYZDABCEO,"Its a Command pattern. In the above code, the interface IPrint defines the print method. This print method is implemented differently by the two classes that implement this interface. When the print() method is called by the printMethod()  it does not know how it is going to be implemented.","The advantage of using command pattern is that the caller can issue commands without worrying about how the command is getting implemented. This results in a low coupling between classes.The disadvantage is that if there are plenty of such short commands, it makes it difficult to make the program readable and also makes it a little hard to maintain the program.""Bangalore Narasimhamurthy, Ashwini","If the actual types of arguments to the method call had to decide which of several methods to execute, then we would be doing Function Overloading.If we want to sort string objects, then it would invoke the Sort routine for Strings which has arguments that take Strings.If we want to sort Integer objects, then it would invoke the Sort routine for Integers which has arguments that take Integers.Here, the actual type of the objects in the method call determine which function to execute.This would simplify the problem, but for every new class that is added, a new sort routine also should be added.Using Interfaces.We could also use Interfaces for the sorting problem. We can have a comparator interface that has the compare functions. This can be implemented in any class. But this again needs casting of the objects once they are passed to the comparator.",Preconditions that are as weak as possibleStrong PostconditionsIt does matter when you want to achieve correctness for defined inputs.,Activerecord,Principle of Lease Astonishment,Yo yo effect,Liskov Substitution Principle,This does not have a class.The method is private,"Everything should be in a class. To achieve encapsulation.The methods have to be public and variables private. We can use getters and setters to access variables.Also, we can use polymorphism to do this",Give variables the narrowest scopeVariable names niether too short nor too long. Here the name is too long although it is descriptiveUse standard idiomsFactor out duplicate code. This is the most important to be done here.,We can rewrite the code. It will override the methods that are already present in these classes.,"PortfolioStockGainDividendBond ofcourse,( but it is not italicized and Interest class for that)","1. Purchase price and Current price. Price is an attribute of stock. Stock has a paricular price. And its a value for every stock. Hence it cannot be a class, its better if it is kept as an attribute of stock.2. Short term and Long term. These are the properties of the Gain. They can be modeled as attributes of Gain that have Boolean values, true or false. It does not have any behavior or responsibility to perform. It s just an attribute. Hence it is not a key abstraction.",A portfolio is a set of stock positions.,Gain and Loss.The requirements mentioned that negative gain is Loss. This is a little ambiguous. So it is not required to have a Loss key abstraction as well.Gain represents the key abstraction.,"There is no is-a relationship here among any nouns mentions. Hence  it is not necessary or possible to subclass.It does not make sense to define subclass relationship here.Advantages: If there was a remote possibility of subclassing, we could have - code resuse- eliminate duplicate code- used interfacesDisadvantages- Handle unwanted code- Yo-yo effect-Tight coupling between classes and subclasses","Resposibility 1: CalculateTotalEarningsCollaborators: Stock, Gain, Interest, DividendResponsibility 2: AddStock / RemoveStockCollaborators: StockResponsibility 3: CreateRecordCollaborators: Gain",class Exam2 def method_missing(method) puts sayHello is not definedendend end,OverridenAnimal class: public void eat()   (the one inherited from animal class)Horse class:   public void eat() 2nd one overloades the 1st oneOverloadedHorse class:  public void eat()Horse class: public void eat(String s)2nd one overloades the 1st one,"Output:Horse eating hay Since a is of type animal, the superclass is checked first. Actually the refernce to a is of type animal and a is a horse. So, In the superclass it is checked for and since it is overriden in the subclass, the more specialized version is called by drilling down to subclass","Yes.Make the methods Final.In java, If a method has to be prevented from being overriden by the subclasses, declare them as Final.",OE,ABCO,,,"Strategy PatternThis pattern helps you choose an algorithm or strategy for a task, depending on some parameter of the situation.Algorithms are selected at Run-time.Here, depending on Success or Failure, the corresponding method is invoked at Runtime.","Advantage: Easily maintainable code. If u used a case statement instead, everytime you modify the object, ypou will have to modify all the casesDisadvantage:You can use polymorphism. using polymorphism is more straightforward than using Strategy Pattern.""Bhat, Ashwini",,,,,,,,,,,,,,,,,,,,,,,,,,"Bhatia, Hema",,,,,,,,,,,,,,,,,,,,,,,,,,"Bukkapattanam, Achyuth",,Strong preconditions and weak postconditions help in achieving correctness. This is because strong preconditions will easily satisfy weaker postconditions.,Type,principle of least astonishment,,Is-a relationship,code - reuse,We will be using redundant code and hence wasting space.,Instead of writing the if loop we can,"Yes, we need to still rewrite the code guidelines. We can rewrite as follows - assigning can be done in respective classes.","portfolio, position, gain, earnings",value cannot be implemented as a class. This is because it is used as an attribute to calculate gain.shares cannot be implemented as a class. As it is used as an attribute to express the quantity of a particular stock.,,gain,,Responsibility - total returnCollaboration- earningsResponsibility- sharesCollaboration- position,"class Exam2count = 0  def method_missing(meth, *args)    puts #{meth} is not defined.   class_eval %Q?    def meth       puts Hello from #{meth}    end     ? endend",eat() method in Horse class over rides eat() method in Animal.eat(String s) in Horse class over loads eat() method eat() method in Horse class.,"Horse eating hay. This is the output of the above program.This is because, eat() method in Horse is more specialized when compared to eat() method in Animal class. That is eat(0 from Horse class overrides eat method in Animal. So, it is invoked when a.eat() is called.","public class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }     public void eat() { //method 1        	System.out.println(Horse eating hay );     }     public void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}","E + merge(O, O) = EO","X+ merge(AO,BO,CO,ABC) = XABCO","Z + merge(AO,DO,AD) = ZADO","Q + merge(XABCO, YADEO, ZADO) = QXYZABCDEO",Adapter Pattern,Advantage: The main advantage of the Adapter pattern is that it allows the Client to use the Adaptee with minimal modifi cations to either class.Disadvantage: A disadvantage of using the Adapter pattern is that you have introduced yet another class into the design and therefore made it slightly more complex."Cameron, Jarrod",The problem in Java is that the compiler only knows the objects declared type. The actual type of the object isn't determined unti runtime and therefore the compiler does not know which compare method to call.If Java used the actual types of the arguments to decide which of several methods to execute then the compiler wouldn't throw and error and we wouldn't have to a Compiler interface as in the lecture.,You want your preconditions to be as weak as possible so the client does not have to perform a lot of checking.You want your postconditions to be as strong as possible so the supplier is able to cover all cases.,Active Record,Principle of least astonishment,Yo-yo effect,Liskov substitution principle,The method does more then one thing,"By violating this rule, the method becomes messy and more difficult to understand.A programmer has to spend time reading through the entire method to determine exactly everything it does.",This method should be broken up into separate methods for each individual action.There should be:makeAnotherCircle(Shape inShape)makeAnotherRectangle(Shape inShape)makeAnotherCylinder(Shape inShape)This also easily allows adding other types of shapes.,You could use delegation to incorporate the system-defined classes into your methods.,PortfolioPositionShareRecord,"purchase price - This is just a primitive type, it simply would be a float.earnings - this is not a singular noun.",A Portfolio is an aggregation of Positions,"Shares, the term can represent stock and bonds. It also can represent a quantity as defined in the requirements.",Position could have the subclasses StockPosition and BondPosition.The StockPosition would have a dividend attribute while BondPosition would have an interest attribute.,Responsibilities:Knows PositionsCalculate total earningsCollaborators:PositionShares,"class Exam2   def method_missing(meth, *args)      puts #{meth} is not defined      eval %{def #{meth}(*args)           puts Hello from #{meth}         end}   endend",Method 1 overrides method 0.Method 2 overloads method 1.,Output: Horse eating hay  The declared type of the object is Animal but dynamic method invocation determines that there is a more specialized version of the eat method in the Horse class. It therefore will call this method.,"This is not possible in Java, dynamic method invocation always occurs. The only way to prevent both eat methods from being overridden would be to remove the inheritance hierarchy.","E + merge(O,O) = EO","X + merge(AO, BO, CO) = XABCO","Z + merge (DO, AO) = ZDAO","Q + merge(XABCO, YDBEO, ZDAO) = QXYZDABCEO","Command Pattern.The Command Pattern is a design pattern that uses an object to encapsulate all the information needed to execute a command or method at a later point in time. These objects can then be stored and later recalled to then execute the saved command.In Ruby, the Command Pattern can be implemented using Proc objects. The Proc object holds a callable block of code that can be saved and used at a later point in time.",Advantage: Easily allows for more print operations to be added without requiring a lot of work.Disadvantage: The PerformOperation class has no way to know if any errors occurred when a print operation is executed since it is handled in a separate class."Chandra Chavva, Sharath",When actual type of argument is used to decide of several methods then there is no use of dynamic binding so we can directly send in the arguments of required type of function to be invoked.,We should have stronger preconditions and weaker postconditions so in order to get right result algorithm should take very much care.,Active record,Principle of least astonishment,Yo-Yo effect,Liskov Substitution Principle,"It is violating DRY principle and also doing more than one thing in a single method, which should not be the case in o-o languages.","In object oriented languages it is recommended to write just one functionality in each method bu here it trying to convert into Circle, Rectangle and Cylinder as well.","We should rewrite those different functionalities in different methods. The headers of their methods could be convertToCircle(double radius)convertToRect(double width,double height)convertToCylinder(double radius, double height)",yes I would still follow these guidelines because it doing different functionality so it is better to separate different functionalities by putting them into different methods.,"portfolio, portfolio manager, share, record","purchase price, current price, earnings are not key abstractions because they are just numeric values.long term, short term is time which any system(language) has inbuilt feature to keep note of it.Again position is quantity of stock i.e just primitive value.","stocks have purchase price, current price, and gainearnings has parts gain, interest ,dividendsportdolio is set of stock positions","earnings is used ambiguously, it does not correspond to either single stock or single bond but both, i.e it calculates both.","class : Portfolio manager and sub classes : stock , bondyeah common methods can be defined in super class and in sub class we calculate and do operations specific to share and bond respectivly.","calculateStockQty() Share,RecordcalculateEarnings() Share,Record","class Exam2  def mew     puts Meow   end     def method_missing(meth, *args)     puts #{meth} is not defined  Exam2.class_eval(def #{meth}; puts #{meth};end)    meth  end end",public void eat() of Horse overrides public void eat() of Animal and eat(String s) of Horse class overloads with public void eat() of Horse method,O/P ; Horse eating hayBecause the actual class class present in a is Horse so it searches for specialized version of eat() which is present in Horse class. This is process is also called as dynamic binding.,No we cannot prevent dynamic binding in java.,EO,XABC,ZAB,XZABDECY,Strategy design pattern,"Advantages:A family of algorithms can be defined as a class hierarchy and can be used interchangeably to alter application behavior without changing its architecture.By encapsulating the algorithm separately, new algorithms complying with the same interface can be easily introduced.Disadvantages: Clients must understand what are different strategies and how do they differ.""Chhatre, Nikita","If java also followed the principle of seeing the actual types of the arguments , there could be a distinction made between the variors method signatures as public static void sort(Integer[] data) and public static void sort(String[] data).Thus , the integer or string value passed could directly be interpreted statically and binded to the appropriate method at run time.","For correctness,(a) the preconditions should be as weak as possible (b)The post conditions should be as strong as possibleBoth ways we have:If the defensive principle is seen then the postconditions should be able to check for all the preconditions while if the Meyer?s non-redundancy principle is followed then following the precondition should be the responsibility of the client only.",Active Record.,Principle of least astonishment,yo-yo effect,Liskov substitution principle,"Extensibility , code readability Open closed principle and always code to interface.","This method is made static and private. Hence only objects of that class will be able to access it. If tomorrow, some more shapes come up, then we will have to go and modify this private method but according to the open closed principle : Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification, it is not open from extension.Also, a lot of if else statements make code ugly.","-Make an interface Shape-Let shapes like circle, rectangle be classes to implement this interface-In the main program, pass array of interface shape objects.interface Shapes(){convertToShape(Shapes s)}Class Rectangle implements Shapes{...Rectangle convertToShape(Shapes rect){...}}void main(String[] args){Shapes[] shapearray=new Shapes[];Shapes[1]=new Rectangle();Shapes[1]=new Circle();...for(i=0,Shapes shapearray.size >0;i++){Shapes shapearray[i].convertToShape();}}This way we dont have to keep a variable for type of figure. It will be figured out at runtime.",Yes even with system defined classes I would still be able to write the code with a slight variation. I would now create subclasses of system define shapes and write my own methods of converttoShape or another way could be that I have my own classes but use delegation to use objects that are system defined.,portfoliostockrecorddividendgain,1)purchase price and current price should not be key abstractions as they denote a value which will be a primitive type.2)loss should not be a key abstraction as it is derived from the gain,"Portfolio is constituted by stock positions.Thus, a set of stock positions will be aggregated into a portfolio.",stock has a current price and purchase price and also pays dividends which is ambiguously put acrossgain has multiple imp,"short term and long term could be subclasses of gain as they are having different rates at which tax computation is done. Thus, this would be benificial as they can share all the properties of gain and have their own tax value. Thus, code reuse is done.But, the disadvantage would be that subclassing requires all the properties of the superclass to be inherited whether required or not. So flexibility of code is less.","1) maintain record of stock-responsibility     stock,portfolio,record-collaborator1) to calculate total earnings-responsibility    gain,interest,dividend,record,portfolio-collaborator2)to calculate total return-responsibility    earning-collaborator","class Exam2    def method_missing(meth, *args)    puts Sorry, #{meth} is not defined    c=Class.new    c.class_eval do      p=#{meth}.to_s      define_method :p do      puts Hello from #{meth}      end    end    endende=Exam2.newe.sayHello",public void eat() and public void eat(String s) overload each other.andpublic void eat() of Horse class overrides public void eat() of the Animal class.,"Horse eating hay : outputThis is because object a has type of Animal. So, at compile time it will make a call to the class Animal's eat() meythod. But, as dynamic method invocation takes place, the closest possible signature is searched for at runtime to drill down to the most specialized method with the same signature. Thus, as object a has the reference of toye Horse, the mtehod eat() of Horse is available and is called.",One way is to change their signature and make them private.Other way is to not extend the Animal class but to implement delegation by having a reference of the Animal class as an instance in Horse class and calling the methods of Animal class by message passing.This will avoid overriding of methods.,EO,XABCO,ZADO,XYZABCDEO,"This is a command pattern.A Command class holds some subset of the following: an object, a method to be applied to the object, and the arguments to be passed when the method is applied.This is because it gives command for success or failure by storing the objects state for giving command","Advantage:1.A lot less boiler plate code to do (Even if there's also some to do) 2- Easier to execute, more verbose 3- More secure server side by using action validators 4- Abitlity to undo/redo easily Disadvantages:The major disadvantage of the pattern is that it results in lots of little Command classes that can clutter up a design5- Incomming feature : Client cache, batching queuing.""Desai, Niranjan",We can overload the sort method using different arguments for different data types.So when data type is passed it will match definition with exact data type and invoke that definition.,a) weak preconditionsb) strong postcondition,object relation model,principle of least astonishment.,yo-yo effect,Liskov substitution principle,"method is not cohesive. according to oo style, a method should do a single thing and do it well. In this case, a single method is doing everything from deciding  which shape to calculating area of that shape and generating that shape.","If new shape is added we want to add one more if else condition in given function. Then function is too complex, not easily readable and may lead to errors.","static private Shape makeOneShapeFromAnother(Shape inShape, Shape outShape) {outShape.set(inShape)}class Shape {abstract void set(Shape inshape);}class Circle extends Shape {void set(Shape inShape) {// logic to set shape}// similar for other classes i.e. rect and cylinder","Yes. We can create a wrapper class for each shape i.e. circle,rect.which extends basic Shape class. Then we can call methods of that particular shape class from wrapper class to get the new shape.",portfoliodividendsharesshort termlong term,"purchase price, current price = these are just numbers and hence cannot be considered as classes.loss = This is not key abstract as it is same as negative gain.",stock contains number of shares. Hence stock is whole and share is part of that.,negative gain is loss. This is ambiguous. Also bonds can be treated like stocks with difference is instead of dividend they have interest.,short term and long term can be subclasses of gain. Yes it does make sense as basic attributes are same in both classes which are generalized in gain class.Advantage: is code reuse. We dont want to write same methods for both classes two times.disadvantage:,res: maintain number of shares. coll: shareres: calculate total return. coll: dividend,"class Myclassdef method_missing(*args)met=argsputs met,' is not defind.'self.class.class_eval dodef metputs 'hello from',:metendendendend",method 1 overrides method 0 as signature is samemethod 2 overloads another eat method as signature is different,o/p: Horse eating hay because eat method is called for animal object declared.so it will get eat method in animal class and then search for any overridden method in subclass. It finds method in horse class and hence it executes eat() method from animal class.,yes. we can use final keyword for method which is similar to constant. This ensures that methos is not inherited in subclass and hence cannot be overridden.,EO,XABCO,ZDAO,QXYZDABCEO,Strategy pattern as different strategies are used depending upon faiure or success.,1. advantage:  is it creates diff objects inherited from abstract classes which is good example of oo.2. disadvantage:  to much code writing."Dhikle, Aaditi",CLOS allows multiple superclasses and allows static typing.The actual classes of the arguments to the method call do play a role while invoking a method.Will choose a different method to execute where you have superclass type and base class .The sorting problem would be simplified in java in the sense that the sorting method to be used would be defined easily by just looking at the actual type of the method at run time rather than looking for a more specialized version after compile time,"It does not matter. Here is the reason why:Given the original precondition, there can be a strongest postcondition we can give and still have the program be correct.Similarly, given the original postcondition, we can also weaken the precondition.  	From a formula that holds, you can always get another one that holds by strengthening the 	precondition or weakening the 		postcondition      .It is possible to give a precondition strong enough that the program is correct regardless of what it does.      .The only criteria that needs to be satisfied is :Consider again the Liskov Substitution Principle:Class S should be made a subclass of class C only if, for every method with identical signatures in C?s and S?s interface,?	the preconditions for C?s method are no weaker than the 		precondition for S?s method, and?	the postconditions for C?s method are no stronger than the 		postcondition for S?s method.",method aliasing,principle of least astonishment,yo-yo effect,liskov substitution principle,The oo rule that is being violated here is the one in which states that a particular class should do 1 thing and do it wellAlso theer should be a fnction which does that comparing of the type and then calculates the radius or width etc. and then calls the method to create the reqd shape,It is bad to violate this rule because it leads to low cohesion in the class. Hence all the methods and variables in the class should contribute towards the same single function only in order to promote high cohesion,the style guidelines say that the methods that repeatedly do the same thing must be written in the same function and then this single function should be called whenever it is needed,Even if these were system defined classes there would be no much change in the code except for the fact that comparing the type of each and calculating the radius/width would be easier. But overall that would be of not much help because changes are required in the function,portfoliostockdividendearnings,purchase price ansd current price: are only numerical values short term long term: essentailly have the same functionality,portfolio has- a stock: portfolio is the aggregation of a number of stocks,value of a stock and current price...essentially mean the same thingbonds and stocks,earnings can be a superclass to calculate the  as gain + interest + dividends in different cases,"knowing the current value annual rate of increase, gain or loss, tax maintain stocks  collborator: stockgenerate record: stock",class Exam2    alias :sayhello :sayHello2def sayHello2    sayHelloenddef method_missing(arg)sayHello is not definedend,method1 overrides method 0method 2 overloads method 1 and 0,"Horse eating hayDue to dynamic method invocation, in the 1st step at complie time the method eat in Animal is chosen. At run time in step 2, the method that is a specialized form of the method chosen at complie time is chosen. this is the eat method in horse. Is is due to overriding","The methods are being modified due to the eat method defined in the Horse class. If we could not defined that method in the Horse class then the eat method from Animal will be called.And for the method 2 to be called , we simply have to call the eat method with an argumentclass Animal   {      public void eat()  {  //method 0       	System.out.println(Generic animal eating generically);    }}public class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();a.eat(grass);     }        public void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}",EO,XABCO,ZDAO,QXYZDABCEO,"Strategy pattern.The interface IPattern has a print method, which is being implemented in two different ways ie Success and Failure.The getter and setter methods can be used to determine which strategy is to be used for printing. Thus, based on the arguments the program decides which strategy to follow","A Strategy Pattern, enables us to customize an algorithm, deciding which algorithm has to be made use of depending on a number of dynamically changing factors. A given strategy has many methods associated with it.disadvantage: increased number of objects.""Dodeja, Vivek",,,,,,,,,,,,,,,,,,,,,,,,,,"Dsouza, Melroy",by using overloading,Assuming that correctness here pertaining to the function being calledPreconditions should be as strong as possible.This helps restrict possible input combinations with which the callee(supplier has to work with) and hence it can guarantee a correct output better.Post conditions should be as weak as possible.By reducing the postconditions it allows the function to generate more combinations of output that may seem correct(however this may reduce the correctness from the point of view of the system),Object relational mapping,Principle of Least Astonishment,Yo-Yo effect,Liskov Substitution Principle,The type of Shape is defined by an external variable String typeAn object should include all its information pertaining to it,Keeping the type information seperate lowers cohesion.,We can introduce an interface ShapeType with a function getType. Shape uses the interface to determine its shapepublic interface ShapeType{   public void getShape()}public class Shape implements ShapeType{  public void getShape(){},YEs we can create a new class which has the system-defined class as a object in it (delegation ) and provides the required interface,"Porfolio,Record,Position,",puchase price : it is an attribute of stock heldearnings :  it is a value that is variable by time(prcie of stock) and has to be calculated,Portfolio(whole)Stock(part),"GainIt is defined as loss ,different in erms of bond and stockalso varies with time","Position subclasses:-Stock,BondThis relationship provides code reuse(position can contain quantity also methods like calculateEarnings can be reused), Is-a relationship(stock is a position,bond is a position),they have the same public interfaces and are polymorphic.Hence it can be used as subclass","Responsibilities(Collaborator):calculate the total earnings(Record,Position)purchase a stock (Position)",class Exam2 def method_missing(func)  str = func.id2name  puts(#{str} is not defined)    Exam2.class_eval do    define_method func do      puts(Hello from function #{func})    end  end    sayHello  endend e = Exam2.new e.sayHello e.sayHello,public void eat() overrides eats() in Animal class public void eat(String s) overloads eat() in Horse class,o/p: Horse eating hay We call a.eat();since a is Animal type it accesses eat() in Animal class.However this is overriden in Horse class and the reference points to Horse object.Hence overriding takes place and eat() in Horse class is called,"No. If a method overrides another method in base class we cannot prevent it from being called since Dynamic Method invocation is used in JAva.However,to prevent overriding we can STATICALLY change the class by changing the method signature to something diffrent from  public void eat() .",EO,ABCO,ZDAO,QXYZDABCEO,Strategy pattern,Advantage:1)It seperates the algorithm. And it allows oppurtunity to select the algorithm at runtime2)We can easily add a new class that implements Iprint and provide a new algorithmDisadvantage:1)Increase the number of classes and hence complexity of system(especially when algorithm is trivial as print in above case)"Ezen TA, Aysu",,,,,,,,,,,,,,,,,,,,,,,,,,"Gade, Sindhura","If Java used the actual types of the arguments to decide which of the methods to call, we could stop at the second iteration itself because there would be no conflict in the Comaprator regarding which compare method should be called as the method to be called would now depend on the arguments that are being passed.","In writing preconditions and postconditions, in order to achieve correctness it is always better to have as less preconditions as possible so that the postcondition gives error when a wrong input is given.When we have a set of conditions we can get another condition by strenthening the precondition or weakening the postcondition.",dynamic binding.,The principle of least Astonishment.,Dynamic method invocation.,Liskov Substitution Principle,"It violates the basic rule of object oriented style that encapsulation of  the behaviour and state should be done in classes. Here it uses the if else statements to determine the code that it should execute rather than defining a method in each class for circle, rectangle etc.. that has the code inside the block. We could then call the particular method on an object of each class.","It is bad to violate this rule because when code is written like this the code is not general. If some new kind of diagram is added, then we need to modify the code to accommodate this new code and if we remove a particular shape we need to delete code. If it is written in an object oriented manner, then we just need to add a class or remove a class.","We should rewrite the code by defining classes for the circle, rectangle and cylinder and then defining methods in them that execute the statments for creating a new shape.Then we could write code like else if(type.equlas(square){Square.newShape(x,y,area);}Here newShape would execute a similar code that is within the if else statements.","If they are system defined classes. Then we cannot rewrite the code unless we know the full implementation details of those classes. Else we would mistakenly override some methods that are already present and this would results in erroneous behavior. If the implementation details are known, then we can write a method in those classes after inheriting them and call those methods on the objects of the classes.","Portfolio, Stock, PortfolioManager, Record",quantity is not an abstraction because it is can just be denoted by a primitive type as it is the number of shares.earnings is not an abstraction because it is calculated for a particular portfolio based on the attributes of the portfolio.,Gain could be an aggregation of short term gain and long term gain. Because gain is calculated in only one way but depending on whether it is short term gain or long term gain we need to calculate the tax accordingly.,Stock is used ambiguously because it is also referred to as shares. The correct use is Stock.,we can define subclass relationship for the shortterm long term dividend interest where these can be subclasses of gain as they do some additional calculations on the gain.,Portfolio should know the quantity of the various stocks ---Collaborator : StockPortfolio should know the value of  various stocks ---Collaborator : Stock,"class Exam2def method_missing(meth, *args)puts #{meth} is not definedendendExam2.class_eval dodefine_method : sayHello doputs Hello from sayHelloendendclass Exam2def method_missing(method)str = method.id2namesayHelloendend",The method 1 overrides the method 0 that is present in the Animal class. The method 2 overloads the method 1 that is present in the Horse method.,"The output is Horse eating hay. This is because during runtime, since a is declared as an animal it first finds the eat() method in animal but because the actual type of the method referred by a is horse it looks for a method eat() in horse and since it finds it it executes the same. Dynamic method invocation.","Yes we can prevent both the methods from being overridden by declaring their type as private. When the methods are private, even if another class inherits this class it cannot override the private methods of this class.",EO,XABCO,ZDAO,XCYEZDABO,"the design pattern that is implemented in the above code is the Strategy pattern. In the strategy pattern there are several set of methods of similar type which depend on the parameter. A strategy might have a number of methods specific to the algorithm. Most often strategies will be instantiated immediately before executing the algorithm, and discarded afterwards.","the advantage is that Using encapsulation the algorithm separately, new algorithms complying with the same interface can be easily introduced. The disadvantage is that the application must be aware of all the strategies to select the right one for the right situation.""Gholkar, Ameya","If actual arguments were handled correctly by Java it would be much simpler because we would not need the extra comparator interface and methods to actually decide which one should be used. The types would automatically decide this.Thus, proper comparator will be executed depending on the types of arguments which could by pass dynamic method invocation.",Preconditions should be as weak as possible and Postconditions should be as strong as possible.This will make sure that the specified function is executed in all possible cases OR handles all possible cases. The most ideal case would be something that does not have any preconditions but has the strongest postconditions.,ActiveRecord in Rails; Hibernate; - Object Relational Mapping,PLA - Principle of Least Astonishment,Yo-yo Effect,Liskov's Substitution Principle.,It has assimilated a lot of logic about different shapes within itself. It would have been much better if there was a method in which can be called for each of the types of shapes.A method should do one thing and do it well.,"It is bad because it makes the current function the nexus of everything. So, if a new type is to be handled it should be put in this function and thus could make the function un-readable. Adding a new shape would mean more code - which includes the functionality too.","The style guidelines say that we can have different functions for different shapes which take in the required arguments and return the required shape. This would make the code more readable.We can have:getCircle(double x, double y, double area)getRectangle(double x, double y, double area)getCylinder(double x, double y, double area)",Yes. I think we can.,"Gain, Record, Portfolio, Value","Loss, short term, long term, TaxLoss should not be a key abstraction because it can be easily calculated through the value of the Gain. Tax is a derived value which can be calculated from some base values. Hence there is no need to maintain Tax as a key abstraction.Short term and Long term are not key abstraction because they are types of Gain and thus not independent entities.",A Portfolio has a set of Records of Stocks.,record is the one which is mentioned ambiguously. It is better explained in the portfolio where a record should be added and deleted.,One possibility where we can have a subclass relationship is :Gain -> Short Term Gain and Long Term GainIt makes sense because the problem statement mentions that differentiation of Gain is important as both the types are taxed at different rates. - SpecializationAdvantages:We can work with the Subclasses with different tax rates and also could use the specialization for other functionalities in the system.Disadvantages:,Portfolio - Class NameResponsibilites and Collaborators:Remove a record if the Stock is sold Add a record if the Stock is boughtCalculate the total earnings - BondManagerCalculate the total return - PortfolioManager,"class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined    eval %{      def #{meth}        puts Hello from #{meth}      end        #{meth}    }  endendc = Exam2.newc.sayHelloc.sayHello",Method 1 OVERRIDES Method 0Method 2 OVERLOADS Method 0Since Horse inherits from Animal.,The above program should print:>> Horse eating hayReason:The Horse class has defined its own version of eat() method after inheriting from the Animal class. This effectively overrides the eat() method in the Animal class and thus due to dynamic invocation in JVM; eat() of Horse is called at run-time.,"If both the methods in Horse class should not be overriden, then they should be declared as final. i.e.  final public void eat() { //method 1        	System.out.println(Horse eating hay );     }     final public void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }This will ensure that any class inheriting from the Horse class will not override these two methods.",EO,XABCO,ZDAO,QXYZDABCEO,"This code uses Strategy Pattern.The Strategy pattern is designed specifically to allow the Client the freedom of the use of multiple definitions of a function or Strategy. The most common example is the Program which uses multiple Sort functions. It gives the client freedom to set any particular Sort function and call it through a common interface. Thus, this pattern makes it possible to encapsulate algorithms into classes and then use and call them through a context or an interface. The main definition of the strategy pattern is as follows:Strategy pattern is a pattern which encapsulates a defined family of algorithms and thus makes them interchangeable. Thus, Strategy pattern allows the Client to change algorithms according to his will. Execution of the Algorithm will take place through a crystallized and common interface.The Strategy pattern comprises of different participants:a) The Algorithm or Strategy Interface - provides the actual method to be implemented. i.e. in this case: print()b) The actual Strategy - Encapsulates the logic behind execution of the function. This class MUST implement the Strategy interface and write the logic for it.c) The Calling Context - the class from which the method of either strategies are actually called. It is at this class that the Strategy to be used is set. - in this case: PerformOperationThe code above uses the same logic.The Function or Strategy here is the Print Function. There are two options - Failure or Success. It is on the discretion of the process within the Client that one particular strategy can be used. Thus, PerformOperation allows the Client to set a particular function and call it through a common public function - printMethod().",Advantage:Client can easily add or delete any algorithm which is not needed at any point of time. This pattern allows us to have highly extensible code. Classes encapsulation definitions of needed functionality can be added and removed at any point of time. It also avoids the problem of one big fat class with all functionality.Disadvantage:Clients must be aware of the different functionalities and hence can be exposed to implementation details. They thus should know how the different strategies differ from each other and in what context."Gopal Bandla, Pavan",,,,,,,,,,,,,,,,,,,,,,,,,,"Gujar, Sachin",,"Preconditions that are as strong as possible and postconditions that are as weak as possible.Because if a precondition is satisfied, then a stronger precondition is always satisfied. Similarly if a post condition is satisfied, a weaker postcondition is also satisfied.",Model.,Principle of least astonishment.,Yo-yo effect.,Liskov substitution principle.,"The method is defined as static. So, it can be invoked without using the  object of any class. This method works a function defined in a non-object-oriented programming language.","Ideally, in object-oriented language, each operation must be performed by send a message to an object. Objects must communicate with each other by sending messages to each other. Violating this rule introduces the non-object oriented nature in the program.",The method should be defined an instance method of  class Shape.public Shape makeOneShapeFromAnother(String type)  {// method definition},"Yes, we can make these classes as subclasses of class Shape.",PortfolioPositionStockBond,1)value - it denotes numeric value and therefore it can be implemented using primitive type supported by language. e.g. int 2) purchase price - it denotes numeric value and therefore it can be implemented using primitive type supported by language. e.g. int,There is one to one relationship between the position and stock.,"Gain is used ambiguously in the requirements. It represents a numeric value. So there is no need to use it  as a key abstraction. But at the same time two types of gain are specified - short term and long term. So, it may be necessary to define a separate class for gain and then make two subcasses of it.","Bond can be subclass of Stock since it has many attributes common to  the class Stock like  a purchase price, current price etc.",Collaborators : PositionRecordResponsibilities: Know the position of each stock Know no of stocks,class Exam2 def method_missing(method)  puts #{method} is not defined.  eval %{def #{method}           puts Hello         end}           endende = Exam2.newe.helloe.hello,The 'method 1' of class Horse overrides the 'method 0' of class Animal and the 'method 2' of class Horse overrides the 'method 1' of class Horse.,"Output: Horse eating hay Reason: The declared type of object a is Animal. So the compiler looks in the class Animal to find the method which matches the called method's signature. It is found that 'method 0' matches the signature. Now at runtime, the actual class of object a i.e Horse is looked up to see if it contains the method with similar signature. It is found that 'method 1' matches the signature. So, the 'method 1' of class Horse is called at runtime. This is called dynamic method invocation.","Yes, it can be done. It can be done by declaring both the eat methods of class Horse as final.",EO,XABCO,ZDAO,QXYZDABCEO,"Adaptor pattern. Here, the PerformOperation class wraps the instance  Iprint interface (object of either Success or Failure).Whenever, a print operation is needed or whenever print operation needs to be set, it can be done using the instance of PerformOperation  without directly accessing the Iprint class methods.","The advantage is that if a programmer adds more subclasses of the interface, he doesn't need to worry about how to create and set the instances of those subclasses as that work is done by the PerformOperation class. The disadvantage is that if the""Gumashta, Vaibhav","If Java used the actual types of arguments to decide which of several methods to execute, the compiler could determine by the argument type at compile time, which of the sorting method to call.","It is better to have postconditions that are as weak as possible, or strong postconditions.According to Liskov Substitution Principle discussed  concerning when it is acceptable for a class B to be a subclass of a class A:It is acceptable to make B a subclass of A only if for every public method with identicalsignatures in both A and B, the preconditions for A's method are no stronger than thepreconditions for B's method and the postconditions for A's method are no weaker than thepostconditions for B's method.For example, consider a method that performs binary search on aninteger array. A precondition to using binary search is that the array is sorted. If the methodneeds to check that the array is sorted and, if not, throw an exception, then the procedure'sefficiency is reduced from O(log n) to O(n).",Adapter  pattern.,Principle of least astonishment.,,Subclassing.,Reusability,This limits the,,,"Stock, Portfolio, Record, Dividend","Gain:Since gain can be calculated from: the difference between the value of the stock when it was bought and its current value.Position: Since position is a quantity of a particular stock, it can be stored in each stock object as an attribute.",Portfolio contains stocks.,"Short term / Long term gain. It is not clearly defined how much is short term and how much is long term, which in turn influences the tax rates.","A bond can be defined as a subclass of a stock. It makes sense since the only difference between a bond and a stock is that instead of dividends, they pay interest.Advantages:1. Avoiding code duplication2. Uniform interfaceDisadvantages:1. Coupling is possible2. The behaviour of interest viz a viz dividend might be confusing.","1. Adds stock. Collaborator: Stock2. Generates total earning. Collaborator: Stock, Bond","1.class Exam2  def method_missing(method_name, *args)    puts #{method_name} is not defined.  endend2.class Exam2  def method_missing(method_name, *args)    define_method(method_name) do       puts Hello from #{method_name}    end  endend3.class Exam2  def method_missing(method_name, *args)    define_method(method_name) do       puts Hello from #{method_name}    end  endendnew_exam = Exam2.newnew_exam.say_hi> Hello from say_hi",,,,"L[E] = E + merge(O, O)  = EO","L[X] = X + merge(AO, BO, CO, AB, BC, CA) = L + ABCO = XABCO","L[Z] = Z + merge(DO, AO, AD) = ZADO","L[Q] = Q + merge(XABCO, YDBEO, ZADO) = QXABCOYDEZ","Strategy Pattern.Strategy Pattern lets the algorithm vary independently from clients that use it. To use it, we define a family of algorithms, encapsulate each one, and make them interchangeable.","Advantage:The advantage of this pattern is that the code is declarative. Instead of procedurally creating a strategy and handing it off, you declare that the consumer uses a specific strategy. This makes the code match the intent a little more closely.Disadvantage:The disadvantage is that it is difficult to choose strategies at run time. If you need to change strategies on-the-fly, use a more traditional dependency-injection approach.""Gupta, Ankur","Sorting problem would be solved by using concept of overloading. We can define different sort methods which accepts different type of inputs. So, in that case the compiler will match the method with closest match to parameter passed in call at  compile time and not at runtime.","Preconditions must be strong and post conditions must be weak. According to correctness formula{Pre} S {Post}Here S is the execution unit.Pre conditions need to be taken care of before execution of the program. So the stronger the preconditions are the more correct is the program. In the sense, that the output obtained after execution will satisfy the post conditions only if preconditions are strong i.e. preconditions verify that the input to program is correct.",Object Relational Mapping,Principle of Least Astonishment or Surprise,Abstraction,Inheritance.,A method should do only one thing and do it well.,"It is bad to violate this rule because you end up putting all functionality in one method and not separating the responsibilities. This makes your code less readable. Also, it handles the responsibility of calculating the parameters defined in the other classes.","static private Shape makeOneShapeFromAnother(Shape inShape, String type) {   Shape outShape;   double area, radius, width, height;   double x = inShape.getXPos();   double y = inShape.getYPos();   area = inShape.area();   if (type.equals(circle)) {     outShape = new Circle(area).getShape(); // Assign a circle   }   else if (type.equals(rectangle)) {     outShape = new Rect(area).getShape(); // Assign a rectangle   }   else {     outShape = new Cylinder(area).getShape();//Assign cylinder   }   return outShape;}In circle, rectangle and cylinder class we need to define constructors that take area as input and method getShape() which manipulates area and return the object.",Yes. We can extend the system defined class and define a new parameterized constructor and method to return object of particular type.,"Portfolio, Record,Position,Price,Stock",Bonds: This is because Bonds are particular kind of stocks in portfolio manager.Gain or Loss: It is a primitive data type which is calculated depending on the stocks current value and the buy value.purchase price and a current price:Primitive data type.,Each stock has a purchase price and a current price.Here Stock class has Price object holding the different price values of the Stock.,Stocks: Here stocks are mentioned as set of shares and also treated like bonds. This makes the requirement ambiguous because of difficulty in differentiating stocks with bonds and shares. Its the use of identifying the abstraction clearly when there is not ambiguous statement used in the requirements. Example: Price.,Stock can be super classBonds and Shares can be subclass.It makes sense only if there is a differentiating factor between Bond and a share.Advantages: 1) Subclass will help implement special functionality in their own Bond and share classes. 2) Common variables and methods like price can be defined in superclass rather than creating redundant code in subclasses.,Portfolio Responsibility 1: storePositions and addStockCollaborator 1: StockResponsibility 2: returnStockParametersCollaborator 2: Portfolio_Manager,class Exam2class_eval dodef method_missing(*args) puts #{args} is not defined enddef sayHello(*args)  puts Hello from sayHelloendend ende = Exam2.new e.sayHelloe.sayHello,method 1 overrides method 0method 2 overloads method 1,Output: Horse eating hay. It is because the method in Animal is overriden by Horse class and the reference of type Animal with Horse object will call Horse method on calling overriden method. This is known as Dynamic binding.,Yes. By making class as final we can prevent it from being part of inheritance.,"E + merge(O,O) = EO","X+ merge (L[C],L[B],L[A],CBA)X+ merge (CO,BO,AO,CBA)= X+CBAO=XCBAO","X+ merge (L[D],L[A],DA)Z+merge(DO,AO,DA)=Z+DAO=ZDAO","Q+merge(L[Z],L[Y],L[X],ZYX) ------> EQUATION 1L[Z]=ZDAO ( FROM ABOVE)L[X]=XCBAO (FROM ABOVE)L[Y]=Y+merge(L[E],L[D],L[B],EDB)= Y+merge(EO,DO,BO,EDB) = YEDBOSubstituting values in equation 1Q+merge(ZDAO,YEDBO,XCBAO,ZYX)= Q+ZYEDXCBAO=QZYEDXCBAO",Strategy Pattern,"Advantage: Separate algorithms into classes that can be plugged in at runtime.Disadvantage:In case of  a generic implementation,strategies cannot be chosen at run time. This is because Generics are evaluated at Compile Time and not run time.""Gurram, Srikanth","If Java used actual types of arguments to decide which of several methods to execute,it would be simplified",Having strong post condition is better because the post condition is the obligation of the supplier which is only one when compared to the many clients whose obligation is the precondition.Also there is a design principle stating Try to make your methods do something in all the cases so that there are no preconditions,ORM: Object relational Mapping,PLA : principle of least astonishment,the yo-yo effect,LSP liskov substitution principle,DRY principle.,It is bad because in a object oriented style we should be able to do code reuse.,we should implement an interface which has one method to compute the area and have it implement on all the shapes and define the specific methods in side each shape.,,portfoliopositionrecorddividend,"purchase price and current price should not be key abstractions as they are specific type of priceshares is not a key abstraction as it is redundant, we capture that information by stock.","gain -> [short term, long term]This is important because there are different tax rates.",position is used here ambigously one meaning is number of shares a particular stock has and also it can be interpreted as the position of the stock wrt to other stocks.,"we can define a superclass price which will have purchase price and current price as its sub classes.yes it is advantageous to have this relationship because, the design will be more elegant.",Responsibilites of Portfolio class1. knows the current stock holdings2. keep track the price change for stocksCollaborators1.position2.price,class Exam2  def method_missing(method)    puts #{method} is not defined         eval %{def #{method}           puts Hello from sayHello         end}  end      ende = Exam2.new e.sayHello e.sayHello,method 1 over rides method 0method 2 over loads method 0,"Horse eating hay.a is a declared object of animal type, so it looks for the eat method in the animal class first, then it checks whether there are any methods that are over ridden in the subclasses and invokes them(Dynamic Binding)Hence the eat() method of subclass is called.","To prevent a specific method from being overridden use the final modifier on the method declaration which means this is the final implementation of this method, in the inheritance hierarchy. public final void eat() { //method 1        	System.out.println(Horse eating hay );     }     public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }","E+merge(O,O) = EO","X+ merge(AO, BO,CO,ABC) = XABCOfollowing the principlesif the element we are looking is in the tail of any other list we move to next set.if we add a element in to the list,then we start from start i.e left most element in the merge set","Z+merge(DO,AO,AD) = ZDAO","Q+MERGE(XABCO,YDBEO,ZDAO,XYZ) = QXYZDABCO",Strategy pattern,Strategy lets the algorithm vary independently from the clients that choose it."Hasian, Ryan","Only one comparator class would be needed, with no need to cast values.  We wouldn't need separate classes for StringComparator, IntegerComparator, etc.  The base Comparator class would figure out what compare method to use with the actual types.","a) Preconditions as weak as possible, so that the maximum amount of correct input is covered.b) Postconditions as strong as possible, so the possible output is most accurately described - so that only possible results satisfy the postcondition.",,Principle of least astonishment,,Liskov Sustitution Principle,A method shouldn't do multiple things - inside of each if/else block a calculation is done and then the outShape is generated from that.,Methods can become overly complicated and difficult to understand or add to.  It also hurts code reuse if multiple methods will try to do the same sort of thing.,I would create new methods for each shape and set outShape equal to the method call.private Cylinder makeCircle {...}private Cylinder makeRectangle {...}private Cylinder makeCylinder {...},Yes - I didn't need to modify the classes themselves.,"Portfolio, share, record, gain","Purchase price is not a key abstraction since it is a single numerical value - it should be a property of Stock.Earnings is not a key abstraction, since it is a numerical result calculated from properties of portfolio.  It should probably be implemented as a method of Portfolio.",The Portfolio contains shares.,"GainGain is defined as the difference between the value of the stock when it was bought and its current value, which can also be short term or long term.  This is the use that represents the key abstraction.  It is also considered a loss in the case of being negative.  It is also treated as a singular numerical result in calculating earnings, which ignores the long term/short term aspects and looks at the resulting gain.","Bonds could be a subclass of stocks since they have the same properties, but they pay a different thing...dividends vs. interest.  The advantage is the reduced code and any shared functionality.  The disadvantage is that Bonds don't do everything stocks do - rather than extending stocks with extra functionality, functionality must be changed.","Responsibility1: Know stock positions ---Collaborators:  ShareResponsibility2: Calculate earnings---Collaborators:  Gain, Share, Bonds",class Exam2  def method_missing(method)    str = method.id2name    puts str +  is not defined.    def #{str}      @#{puts Hello from  + str}    end  endend,Horse's eat() with no arguments method overrides Animal's eat() with no arguments method.  Horse's eat(String s) overloads eat() by providing an implementation with different parameters.i.e.method 1 overrides method 0method 2 overloads method 1,"Horse eating hay The above is the output.  It is called from Horse's main function.  In the main function an Animal is initialized as a new Horse and that Animal calls its eat() function without parameters.   Since Java looks in the actual rather than declared class first for the method, the overriden eat() method without parameters for Horse was called.","Yes, by declaring them final, static, or private.",EO,XABCO,ZDAO,QXCYBEZDAO,This follows the strategy pattern since it chooses which print algorithm to use depending on the situation.  In the case of failure the Failure class is used and Success is used in the case of success.,"One advantage of the Strategy pattern is dynamic adaptation.  Factors can dynamically change and it is useful to have multiple strategies to choose from, rather than handling a bunch of if/else statements.A disadvantage is that the strategy pattern increases the number of objects the program uses, which could takes up space.""Hoode, Chandan","If Java used the type to call the methods then, it would see the class of the arguments. In our sorting example, if we had sent string data then it would know exactly  that the string method for sorting needs to be called.  It would save us from creating different comparator methods for different types like string comparator or integer comparator.","a. a pre condition should take into account all the possible/expected values into account. However since errors are bound to occur, we can have a weak pre condition. b. usually it is preferable to have a strong post condition that specifies all possible output for a particular function. However consider the function of binary search, which searches the element provided it is given a sorted array. If the pre condition does not specify this then the function need to perform this check which reduces the efficieny of the function.",Commad pattern,Principle of least astonishment,yo yo effect,Liskov's substitution principle,The method is declared as static which makes it a class variable and since its private it cannot be accessed by any other class.Also we are doing so many operations inside the same method.A method should ideally do one thing and do it well.,"If any other class inherits this class it would not be able to use this method.Since there are so many things being done in this method, there is high coupling and making localized changes are not possible.",We should have separate methods fordouble x = inShape.getXPos();double y = inShape.getYPos();area = inShape.area();,Yes we could rewrite the code to follow the guidelines as each of them would have their own getXPos() getYPos and area methods.,PortfolioPositionSharesRecordvalue,purchase price and a current price are just the states of the stock and need not be implemented as classes.Position is just the quantity of the stock and need to be implemented as class,A record class,"Gain is used ambiguously.in the sense that the gain is defined as the difference between the value of the stock when it was bought and its current value. A negative gain is called a loss and depending on how long the position was held, the gain may either be short term or long term.",Dividend inherits from the stock. It has all the properties of the stock but is used also in calculating the stocks total return. Subclassing is done so the the stocks existing methods can be used and also a couple of methods for dividend can be added on top of that,"Class PortfolioResponsibilities : get stock positionsCollaborators : sharesResponsibilities : purchase value, current valueCollaborators : price",class Exam2  def method_missing(xmethod)    puts #{xmethod} is not defined.    Exam2.class_eval %{def #{xmethod}                puts Hello from #{xmethod}                end}  endend,method 1 overrides method 0method 2 overloads the overridden method 1(from method 0),"The output is Horse eating hayFirst we see Animal a = new Horse();and int the call a.eat() we see that a is of type animal so during compile time, the Animal class's eat method is selected. However during run time it sees that this method is overriden and therefore it calls the Horse class ear method. This is due to dynamic method invocation","If we make the methods final, then the methods cannot be overridden.by hooking",O,XABCO,ZDAO,QXYZDABCEO,Statergy pattern is being used.,"Advantage Because the Strategy Pattern doesn't rely on inheritance, it doesn't tie subclass to superclass. If only context changes, it shouldn't have to change code outside of that class. And because the Strategy Pattern delegates to a strategy class, it means we can switch out an algorithm at runtime.Disadvantage This would have the disadvantage of catching less errors at compile time""Jalisatgi, Priyanka",,,,,,,,,,,,,,,,,,,,,,,,,,"James, Nivi",,,,,,,,,,,,,,,,,,,,,,,,,,"Jana, Rajan",,,,,,,,,,,,,,,,,,,,,,,,,,"Jayashankara, Sushma",,,,,,,,,,,,,,,,,,,,,,,,,,"Ji, Lu",,"weaker preconditions and strong postconditions. If precondition is not satisfied, the anything can happen, and if precondition is too strong, then checking it may take longer than the execute the method that is being called.",delegation,Efficiency,yo-yo effect,Inheritance,the method variable Shape makeOneShapeFromAnother is not short and simple enough.,"it may take a lot of time to type and, it is not that clear to make people know what it means.",,No.,"portfolio, position, share, dividend","(1)purchase price and current price are not key abstractions, because they are just particular prices.(2)return is not key abstraction, because it is just a numeric value.",The bond and the stock are parts of the portfolio (whole). Each one has the attributes of portfolio.,,"The bond and the stock are subclasses of the portfolio. Because each one has the attributes of a portfolio, like purchase price, current price, but they have their own ways to calculate the interest.(Some part: Bond uses interest and stock use dividend.)Yes. it makes sense. Advantage: It is more clear to calculate the returns. Disadvantage: It may be redundant.","know your purchase price, know the current price       gain(collaborator)know your gain, your interest and dividends    earning(collaborator)",class Helloendh = Hello.newh.sayHellodef sayHelloputs helloendh.sayHelloh.sayHello,The method public void eat() {//method 1 ...} in class Horse override the method public void eat() {//method 0 ...} in class Animal;The method public void eat(String s) {//method 2...} in class Horse overload the method public void eat() {//method 0 ...} in class Animal.,"Output: Horse eating hay Method 1 in the class overrides the method 0 in the class, and when the method eat is called, it calls the method1 and prints out Horse eating hay .",public void chew ()public void chew(String s),,,,,strategy pattern,"advantage:if you have several different behaviors that you want an object to perform, it is much simpler to keep track of them if each behavior is a separate class, and not buried in the body of some method.disadvantage: sometimes it is not that straightforward.""Jia, Wei","We make the compare part to be an interface called Comparator and create several class that implements it. The Comparator just compare objects. And then we can create concrete classes implementing the Comparator interface that compare two objects of one particular type such as string, and throw an exception in all other cases. If you have other type such as integer to compare, just create a class implement the Comparator and compare the two objects of the type integer.","It is better to use weak preconditions and strong postconditions. As when you are writing a routine, it?s not your responsibility to check whether the preconditions are satisfied. Actually, it is not only useless, but actually harmful, to test whether the precondition is met.And a strong postcondition make sure that the code return what you supposed to get.",,Principle of least astonishment,,Liskov Substitution Principle.,"I violate the elegant that object-oriented style does, the code above provide many code redundant.","Every time we need to judge what is the type and the code here exhibits a lot the redundant of the code, it didn't take advantage of code reuse.","Here we should use functional decomposition to break the codes. The guidelines says that use methods, especially private auxiliary methods, for decomposition to reduce duplication of code and to raise the level of abstraction of the code.","Yes, we could reference to those system-defined classes.","portforlio, gain, interest, dividends, stock","purchase price and current price, they should not be implemented as classes, they are just attributes of stock. short term and long term should also not be the class.","it should be the relationship between portfolio and gain, interest, divdends.",positions and number of shares. They actually express the same meaning.,"I think the gain, interest, and dividends are subclass of the stock.","responsibilities:calculate the total earningscollaborators: stockresponsibilites:keep track a set of stockcollaborators: stock,",cclass Exam2  class Exam2   def initialize  end  def self.sayHello   if @@sayHello.defined?      puts sayHello is not defined   else    @@sayHello = new    puts hello from sayHello     end  end  private_class_method  :newendend,method 1 in the class horse override the method 0 in class Animal. method 2 overload method 0 and 1.,it will output Horse eating hay,use the final modifier on the method declaration.,EO,XABCO,ZDAO,QXYZDABCEO,It use command strategy.,One of the main advantages of the Command pattern is that it separates in a Command object the knowledge of what needs to be done (the action) from the object that invokes that code.The disadvantage is that coupling is reduced."Jin, Weiwei",,,,,,,,,,,,,,,,,,,,,,,,,,"Joshi, Nakul",,,,,,,,,,,,,,,,,,,,,,,,,,"Kancharlapalli, Hari",,,,,,,,,,,,,,,,,,,,,,,,,,"Kanitkar, Salil","(1) This would violate the Inheritance principle or the Liscov Substitution principle. This is because an Interger is also an Object. So if the compare method expects Object parameters and you send integer as parameter, the method call should not fail.(2) Also, Dynamic or Late binding comes into effect when the value of the object being sent to the message is used for deciding which method to call.(3) However, if we assume that types of arguments are being used for binding to a method, then compare call would itself be enough.(4) However, the complexity of having to define multiple compare methods specific to each parameter types is still present.","Correct combination should be -(a)Strong Preconditions and(b)Weak PostconditionsWhy Strong Preconditions:(1) Strong preconditions adheres to the OO concept that a function should only do what it is supposed to do and do it well. Stringent preconditions imply that a function need not include code that checks if the input is legal or not. It can just go ahead and do its task.(2) An extremity of this is Strengthening the precondition so that a program is correct no matter what it does.(3) An example: A program which checks if the passed argument is prime or not can specify preconditions that the argument must be a positive integer and odd. This frees up multiple if statements within the function and it only does what it is supposed to do.Why Weak Postconditions:(1) Weakening the Postconditions makes things easy for the function in question since it will evaluate to true for many a larger set of invocations.(2) An extremity of this can be that the postcondition can be weakened so much so that any precondition and program will satisfy the postconditions.(3) For the prime number example, the postcondition can be simple as checking that the answer is not square of any number.",ORM = Object Relational Mapping,Principle of Least Astonishment (PLA),Yo-Yo Effect,Liskov's Substitution Principle,Encapsulation,It does not conform to Object Oriented Concepts.Violating the rule would imply data duplication and code duplication.,"It can be rewritten as - Instead of making it a static method, it should be made an instance method. You can have an abstract class Shape that provides this method.Other classes (Rectangle etc.) would extend this abstract Shape class.",Yes.(1) If we want to provide specific problem or context-specific implementation.,1) Stock2) Portfolio3) Position4) Bond5) Record,1) Quantity: number of shares - can be a number = number of shares2) Return: a calculated number3) Dividend: also a number - associated when a stock is bought4) Interest: also a quantity associated with every stock object,Portfolio contains the stock added.Stock to Portfolio aggregation.,Bond is used ambiguously. They are Stocks but they do not pay dividends. They pay interest.The key abstraction should be Stock itself.,Bond is subclass of Stock,"Calculate Earnings | Stock, Interest","class Exam2   def method_missing(meth, *args)       puts #{meth} is not defined      eval %{	     def #{meth}		    puts Hello from #{meth}		 end	  temp = Exam2.new	  temp.send #{meth}   endend","(1)In Horse class, the 'method1' method overrides the 'method0' method in Animal class.(2)In Horse class, the 'method2' method overloads the 'method1' method of the same class.","The output will be -Horse eating hay    (without the quotes)Why: The declared type of a is Animal. So when it encounters call to eat, it will first match the signature in Animal class i.e. with method0. Then it will look for the most specific implementation of this method ie. method1. So it will call method1 of the Horse class.","To prevent methods from being overridden, they have to be declared final in a class. Final methods can not be overridden by subclasses.So the signatures of method1 and method2 will change as follows - final public void eat() & final public void eat(String s)","L[E] = E + merge(L(O), O)       = E + O       = EO","L[X] = X + merge(L(A), L(B), L(C), A, B, C)       = X + merge(AO, BO, CO, A, B, C)       = X + ABCO       = XABCO","L[Z] = Z + merge(L(D), L(A), D, A)       = Z + merge(DO, AO, D, A)       = Z + DAO       = ZDAO","L(Q) = Q + merge(L(X), L(Y), L(Z), X, Y, Z)       = Q + merge(XABCO, YDBEO, ZDAO, X, Y, Z)        = Q + XYZDABCE       = QXYZDABCEO","This code uses the Pattern StrategyExplanation of Strategy Pattern - (1) Formal definition of Strategy Pattern: the strategy pattern is a design pattern, whereby algorithms can be selected at runtime. Formally speaking, the strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. (2) In the above example, one can have an object of Success or Failure and depending upon the object that is passed in the 'setPrintOperation' method, corresponding action will get executed when printMethod is called.IPrint succObj = new Success();PerformOperation op = new PerformOperation();op.setPrintOperation(succObj);op.printMethod();Similarly for failure objects.(3) In this way, depending on the context, it is going to choose which algorithm to use.",Advantage:It lets the algorithms vary independently from clients that use those.Disadvantage:Increases the number of objects and all algorithms use the same interface.Reference: http://expertiza.csc.ncsu.edu/wiki/index.php/CSC/ECE_517_Fall_2011/ch4_4h_kp"Kantrapati, Mohan","In one of the sort methods we have taken the parameters for the input data as Object. We call the compare method of comparator with parameters as objects[compare(object,object)]This is a good way but unfortunately when two objects of type obejct are passed, due to dynamic method invocation java does not find a compare method with object as parameters. It does not match 'string' (for eg) with the compare(string, string) method. Hence the compiler returns an error. This happens because of dynamic method invocation. If java used the actual types of arguments to decide several methods to execute, then the compare method would be detected and we could get the work done. sorting problem would be greatly simplified if java detected the actual types of arguments. Since it does not we go for other methods like using an interface.",Preconditions that are weak will ensure that the program returns the error. and it also ensures that it doesnt take more time to check the pre condition itself.A strong postcondition is always desirable to ensure the correctness of the program. The supplier will return a correct answer if the postcondition is strong enough.,,Principle of least astonishment,Yo-yo effect,Liskov Substitution principle,One of the rules violated is that we should not have such big function names. Basic rule of object oriented type it violates is that it checks for a class. Everytime we add an object we need to modify this function. We need to add another else condition an modify it.,"Changing the method name increases readabilityIt is bad to violate this rule because when we add a new class, we need to change the method here. We may need to add an other else statement. Making so  many changes to adapt to new additions is not a good o-o principle to follow.","We can have a method name as makeShape()To get around this problem we can use a feature of java that will let the compiler tell us that we need to add new methods when we add a new class. This feature is implementing an interface. We can add an interface like public interface Comp{public makeShape(Shape inShape,Shape type)}Any class that needs to implement makeShape() can implement the interface.","Yes we can still rewrite the code to follow the style guidelines. by doing so any additions of new classes can be handled easily, we need not change the existing things when new classes are added.",,,,,,,"class Exam2def method_missing(meth,*args)puts #{meth} is not definedExam2.class_eval def #{meth}; puts '#{meth}'; endendende=Exam2.newe.sayhello",public void eat() overridespublic void eat(String s) overlaods,It will print Horse eating hay this is because of dynamic method invocation in java. It starts at the class for which the object is called and then goes down and searces for the most specialized method.. That is why we get this output.,"Yes we can change the Horse class. Only eat() is overriddenWe can change the signature of eat() and then it turns from being overridden to being overlaoded. We can say eat(int i) then there would be no overriding,","E + merge(O,O) = EO","X+ merge( AO,BO,CO,ABC)XABCO is the solution","Z+ merge(DO,AO,DA)ZDAO",QXYZDABCEO,It uses Strategy pattern. It helps us choose an algorithm for a task depending on some parameter of the situation. Here in the sePrintOperation() method we are setting the print_operation to value. This value is of type IPrint type. So in the printMethod() we use this print_operation to invoke the print() method on that particular object. (here is is either Success object or Failure object).In this way the strategy pattern helps us choose a method to execute based on a particular value. This is strategy pattern.,Advantage of using this pattern:It helps us customize the algorithm. It gives us the ability to select different algorithms at run time. in the example given we select which version of print() method to run based on a value during runtime.Disadvantage of using this pattern:The application must be aware of all the strategies to select the right one for the right situation.In some cases it is more straightforward to use polymorphism."Karthik Bangalore Ramachandra, FNU",,,,,,,,,,,,,,,,,,,,,,,,,,"Kazgan, Sumeyye",,,,,,,,,,,,,,,,,,,,,,,,,,"Koradhanyamath, Avinash",,,,,,,,,,,,,,,,,,,,,,,,,,"Kulkarni, Mohanish",,"The preconditions could be weak while the post conditions should be precise. We can include the condition checking inside the method in some cases where computation time will not be affected much. In other cases, such as if method expects array to be sorted, preconditions should be strong.",,The principle of least astonishment,Traversing,Liskov substitution principle,The method has too much functionality inside it.,It hampers extendibility and maintainability of the code,Using polymorphism we can have an interface and different shape classes implement that interface. Therefore the method to create a shape will be decided during runtime,yes. we can use adapter pattern,"Portfolio, Share, Record, PortfolioManager","gain, loss, dividend",Portfolio - positions,Position. Second point represents key abstraction,Bonds and shares can be made subclass of stock. It makes sense here because they share most of the funtionality.,"Responsibilites: Add stock to protfolio, Remove stock from portfolioCollaborators:Share, Record",class Exam2  def method_missing(name)    class << self      define,Override: eat() of Horse overrides eat() of AnimalOverload: eat(String s) of Horse overloads eat() of Horse,"It prints Horse is eating hayBecause the declared type of a is animal, it matches eat() of Animal. But due to dynamic bunding, it finds a more specialised version in Horse and so uses that method. (actual class of a being Horse)",One way is to remove method 1.,EO,XABCO,ZDAO,QXYZDABCEO,The above code uses strategy pattern. Strategy pattern allows us to encapsulate a set of algorithms and makes them interchangeable . The algorithm to execute can be selected at runtime.,"Advantage:Encapsulating algorithms in different classes lets you vary the algorithm independently of its contextDisadvantage:Client has to understand how strategies differ in order to use the right strategy.Also, Strategy pattern increases the number of objects in the system""Kulkarni, Niranjan","If java used the actual types of the arguments to be sorted, our system would recognize the exact method to be invoked for this context. We would not have the overhead of type-conversions, message passing, context switching which make the program elegant and is efficient on the machine's part too.",Strong preconditions and strong postconditions. Ensuring that we have strong preconditions and postconditions helps a software achieve expected results. These form a contract between the caller and the callee. This contract when followed judiciously helps even when in the case of ambiguous behavior by the system.,ActiveRecord,principle of least astonishment,yo-yo effect,Liskov's principle,"encapsulation, data should be private",The data of a class should be held private and only corresponding class methods should be able to manipulate them. Leaving the data open to other classes can be a security issue and is an indication of poor design.,You should use an adapter pattern and getter/ setter methods for the data fields.for circle:public double getRadius(){return this.radius;}public void setRadius(double radius){this.radius=radius;},Yes,"stock, portfolio, record, total earnings","price=>because it is like an integral typeholdings=> plural noun, thus no class",total earnings: gain + interest + dividends,holdings.,short term gains and long term gains can be subclasses of gains. These can be good subclasses as gain is either of the 2 not both and it is a is a relation not a has-a. Code written in gains can be re-used in these subclasses,"addStock, collaborator: stockremoveStock, collaborator: record","class Exdef method_missing(meth, *args)     command=nil    puts #{meth} is not defined.    eval %{command=proc{def #{meth}            puts Hello from #{meth}          end}}   command.call   end   end",method 1 overrides method 0method 2 overloads method 1,"output:Horse eating hay i.e. method 1 is invoked.Animal's eat() method gets overridden by Horse's eat() method.At runtime, JRE searches for a specialized version of eat() method in the Horse class (as object a is new Horse()) and dinds one. So that is invoked.",One way would be to make the class Horse a final class.,EO,XABCO,ZDAO,QXYZDABCEO,Strategy pattern,Adv: The appropriate algorithm is called according to the type of object invoking the respective method."Kumar Ramaswamy, Pradeep","Compartor compare(Object data1 ,Object data2) would have called the appropriate function without requiring an interface which actually define the method compare (object data1, object data2).So the code would have compiled without any method compare(object data1 and object data2) and called the appropriate function even if the called was made with compare (Object data1 = String s1, Object data2 = String s2)",Preconditions should be as weak as possible and post conditions should be as strong as possible for program correctness. But this can be relative to the statement which we are evaluating.  We can weaken the precondition for a given a post condition and vice versa.,,Principle of least astonishment,yo-yo effect,Liskov principle,Code Duplication and Executing different parts of the code based on the type.,"If a new shape is introduced, we need write duplicate the code again by adding one more else statement.",We should define an interface shape.Interface Shape {method outshape();}All the other shapes should implement this interace. Class CircleShape implement Shape{radius;method outshape() {return new circle(calcualtion with radius)}}Class RectangleShape implement Shape{}static private Shape makeOneShapeFromAnother(Shape inShape) {inShape.outShape();},Yes. The system defined classes can be used by either subclassing or delegation (referencing).,"Portfolio, share, record, record generator , bonds(subclass of share)",Position is not a key abstraction. Because the position is filled by either a share or a bond. So there is no requirement to represent a position.Dividend or Interest is not a key abstraction. Because the difference is generated by different objects namely share or bond. There is no need to represent this separately.,Portfolio ------------ (n) Share,Gain or loss. This can be either due to the dividends or interest or short term or long term. So this is not clearly defined that when a gain or share for a portfolio should be calculated,"There are two kinds of shares which calculate the tax differently. Shortterm share and longterm share. We can generate these two classes as a subclass for a share class (abstract may be). Advantages: The code is separated and if a third type of share is added, it can be added without affecting the exisiting code. Else we have to add a case statement to handle the new type of share.Disadvantages: This class can be implemented as an interface.",Add a share - shareDelete a share - shareAdd a record - Recordmanager.,class Exam2  def method_missing(method)        str = method.id2name     puts #{str} is not defined    class_eval %Q?     def #{str}        puts Hello from #{str}    end    ?    str   end    end r = Exam2.newr.sayHello,Method 1 overrides Method 0Method 2 overloads Method 1,Horse eating Hay.Dynamic method invocation Happens. So at time the actual class (horse) is checked for the methot eat();,Yes. By using Final keyword.,EO,XABCO,ZDAO,QXYZDABCEO,Command pattern,Advantage : It separates the knowledge of what needs to be done (the print action) from the object that invokes that code which calls the printMethod.Disadvantage: Lots of code.(duplication)"Li, Juanlong","if java use that, we can save time to run the if sentence to decide which method to use. we can directly use what is properly to do the sorting.","It depends. If we use programming by contract, we can see the client and the supplier both have their responsibilities and benefits. This is a mutual process.  A weak precondition will make the postcondition have a large scope to range. The weakest precondition we can give is 'False'.  At this time, the postcondition can be anything. Similarly, a weak postcondition will make things easy for the program. Any precondition and program will satisfy process if we make the postcondition 'True'.",migration,Principle of least astonishment,public interfaces,Liskov Substitution Principle,Simple. Some codes are duplicated which violate the simple rule.Each method should do one thing and should do as best as possible.,There is much code duplication. The duplicated code will increase the cost as well as the complexity of the program.,We should extract a new method from the original code.We should create a new method to deal with different shape.like this:{......if (type.equals(circle)) {    outShape =  dealAsCircle(radius);   }   else if (type.equals(rectangle)) {     outShape = dealAsRec(width);   }   else {    outShape = DealAsCylinder(radius)   }   return outShape;}DealAsCircle(double radius){.....}DealAsRec(double width){.....}DealAsCylinder(double radius){.....},"Yes. Because the codes I changed is not relative to the code inside Circle Class, Rectangle Class and Cylinder Class. The internal variant and method are not affected.",portfolio; position; records; return,loss: loss happens when gain is a negative value. This key abstraction should be one variable in the class position because gain is calculated by the difference of bought price and sold price which are also in position class.short term: this is only a category and it is got from the time period holding a stock. We can decide whether it is a short or a long term by calculate the difference between buying and selling instead of make a class for it.,"position class has the current price and bought price, also it has bought time of a stock.",return is ambiguously. return can be got from gain. but also in the end return is average percentage earnings per year. I think the later use represents the key abstraction.,interest can be a subclass of dividend. because it has the similar attributes of it.,records should get info from portfolio;return is calculated from the information in the position classs.,class Exam2     def method_missing()          eval %{ def sayHello                             puts Hello from sayHello                         end}     endend,eat() method in Horse class override the eat() method in Animal;eat(String s) method in Horse class overload the eat() method in Animal;,Output is:,Horse eating hay,EO,XABCO,ZDAO,QXYZDABCEO,Strategy Pattern,Adv: we can choose an algorithm for a task depending on the specific situation;Disadv: A lot of factors can affect which strategy to use. And these factors can change dynamically. It would be very difficult to capture this by inheritance."Mahabalshetti, Abhimanyu",If Java used actual type of arguments to decide then the problem could be simplified by checking the class of the object passed to the sort routine. Depending on the type of the class a conditional statement would decide the appropriate logic to be applied.,Weak preconditions and strong postconditions,,Principle of least astonishment,Yo-Yo Effect,Liskov substitution principle,Single Responsibility Principle (Each responsibility should be a separate class)The Modularity of code is very necessary very,The code is unreadable. Does not fit in one window. A part of it if needed cannot be reused.,Make shape oriented functions or better make each shape as a different classclass Circleclass Rectangleclass CylinderEach have their own constructor that takes in values to draw.,"Yes, All i have to do is inherit the respective classes and override the methods as needed per the requirement.",PortfolioPositionRecordEarnings,short term/ long term -- variations of common termpurchase and current price -- can be variables of the same class handling the pricesValue -- can be variable of Stock class,"Earnings has parts gain, interest and dividends",Portfolio,No. Each class though depends on one other for some part it is not good to make it a subclass of the other as it is not responsible for all the functions of each other,Responsibility - Collaborator1)Should calculate total earnings (gain + interest + dividends) - Earnings2)Generate record - Record,"class Exam2  def method_missing(meth, *args)     puts #{meth} is not defined     @var=meth   endende = Exam2.newe.sayHello => sayHello is not definedeval %{def sayHello     puts Hello from sayHello   end}e.sayHello=> Hello from sayHello",Method 1 overrides eat() from Animal classMethod 2 overloads eat() from Horse class,Horse eating hayMatches the most accurate definition of function call,Overriding of method can be prevented by using the final keywordpublic final void eat() public final void eat(String s),EO,XABCO,ZDAO,QXYZDABCEO,Delegation,Advantage - flexibility and unanticipated reuseDisadvantage- Excess code"Maheshwari, Gaurav",if Java used the actual types of arguments to decide which of several methods to execute then what will happen is we will not even bother seeing the declarartion of teh object type . We will just see the argument type and go to that Class and just do what the method in there says . In short the concept of Polymorphism will not of no use .,"a. Strong precondition are better because if conditions are weak then what the statement is supposed to do , it will not do properly .b. Post conditions that are as weak as possible because for correctness we can always stregthen the conditon from weak ones to achieve results . If hypothesis is true , then for the statement to be true the conclusion needs to be true but if hypothesis is false then no matter what the conclusion is , the statement will always be true",Concept of Objects and classes . In ruby the the name of the controllers are given as table names.,concept of overloading and overriding so basicLLY pOLYMORPHISM,Inheritance,INHERITANCE . bASICALLY THE LSP principle is written above,the code which is  like if( this) then do that for all the three shapes should not be done there . We shoudl be writing the code for that seperately .Basically inheritance kind of violated here .,It is bad to violate the rule since it make it the code very bad in maintaining. In case we get some other shape to be added in the same way we will need to modify and add the method with condition always . So it is better to use delegation method to improve this,"Well if we use delegation to do this  it will become better since delegation means iNSTEAD OF DOING Something yourself  by inheriting the functionality , you pass a call that is supposed to do sth through another object whose job is to respond to the call . It helps to simulate multiple inheritance without actually inheriting from more than one class . public double AreaRectangle(x,y,radius)public double AreaRectangle( x, y , height,width);public double AreaCylinder(x, y , radius , height);","Yes we can write them still , just that if there is a method which is already existing in those classes will get overridden. But here if those classes of rectangle , circle and cylinder if they are singleton defined in the System then we cannot instantiate , the way the above code has done .",Portfolio managerportfoliorecordStocks,position: This basically can be an attribute if stock short term : it will not be a class since this term can be calculated based on time passed .,a stock has many records so 1:n relationship between them,portfolio  is the one.  It has been used as Bonds but here they dont have dividends tehy have intersest .When a stock is sold so record generated so stock is used as record too . portfolio has shares  can be called shares . The key abstarction will the use of STOCK .,STOCKS can be extended from Portfolio . AND BONDS CAN BE EXTEDED FROM STOCKS . It does make sense to sublcass bonds from stocks since they both pay something one is paying divident and another is paying interest . Disadvantage could be that when we subclass we will have to overiride many methods which defeats teh purpose of avoid writing code again ( kind of duplication but for different implemetation .,"responsibility : calculating dividendscollborator : stocks responsibility: calculate  time for each stock when it is bought and sold collaborator : Stocks,bonds",def method_missing(method)   puts  #{method} is not definedend   e = Exam2.new   e.sayHello   e.class_eval do  define_method :sayHello do        puts Hello from sayHello end end,The method 1 is overriding the method 0 of animal Method 2 is overloading the method 1.,output = Generic animal eating genericallyBecuase a has been declared as type Animal so it will look for the same method signature in animal block of code . Since all animal are not horses it will exceute teh eat method declared in Animal class,Yes if we declare both the methods as final then as we know final methods cannot be overridden . Also we could make the class as final for Horse so then no one can extend that class and no chance of overriding,"E +merge(O,O) = EO","X+merge(AO,BO,CO) = XABCO","z+MERGE(AO,DO) = ZADO","q+merge(XABCO,YBDEO,ZADO) = QXYZABCDEO",This is following the Adapter pattern . It allows classes to work normally together which they could not before due to incompatible interfaces . Here in the above we see that Iprint inetrface is wrapping around its own interface around the existing class Perform operation . because inside the class we can see that all the getPrintoperation is returning a type IPRINT interface. and we have instantiated teh interfce as print_operation . In the printMethod also we see that only after unwrapping the interface we would be abel to print something . The Success and Failure classes are also have been wrapped around by IPrint interfface .,Advantage :  it also wraps around the subclasses which will be good since outside world will have to go throughthe wrapper to get hold of the class methods etc .Disadvantage : Implenting an interface means that class has to implement all tmethods of the interface  which might not be really required for that class. Useless implementations are not encouraged"Manohar, Rohit","If Java could decide the actual types of arguments, we could write a method using 'Generics' in Java. The genericSort(List<E>) would take in any type of list to sort, the compiler would figure out the type of input and call the 'comparator()' for that input type. Thus, a generic function would be able to sort a list of any data type","It does not matter. Preconditions and postconditions do not help ACHIEVE correctness. They are used to CHECK for correct behavior. Correctness can be achieved only by writing code that conforms to the specifications. Preconditions are used to assert that the input is valid, postconditions are used to assert that the result produced is valid. They allow us to gauge the correctness of our code, not help make it correct.",ORM (Object Relational Modeling),Principle of least astonishmen,yo-yo effect,Liskov's Substitution Principle(LSP),"The function name is misleading. It seems that the function transforms the input shape to a different output shape. However, it returns the same shape as the input. The function should be dup() or something similar",Causes confusion in the programmer's mind. He might expect and rely on the function name to build on it. This can cause serious problems in the future.,The function should be getDuplicate()interface shape {shape getDuplicate();},You could extend these classes to include the getDuplicate() function.,"stock, portfolio, portfolioManager, record","1. Position is not a key abstraction. Although the specs say 'A portfolio is a set of stock positions', it defines the quantity of a particular stock. Hence it can be modeled as a member of stock. The key reason is 'It represents part of a state rather than the entity'2. Dividend is not a key abstraction. It is a behavior of the stock object to pay a dividend rather than dividend being a separate entity. The key reason is 'Dividend has a meaning only if it is within the scope of a stock, it cannot exist independently'",A portfolio is an aggregate of stock.,"'position' is used ambiguously in the requirements. In specification 2 'A portfolio is a set of stock positions. Each position is a quantity of a particular stock', position seems to be a metric (quantity) associated with a stock. In specification 6 'Depending on how long the position was held, the gain may either be short term or long term. This matters, because short-term gains and long-term gains are taxed at different rates.', position seems to be used as a substitute for a stock itself.  The former use represents key abstraction.","The possibility is to make bond a subclass of stock or vice-versa. No, I don't think it makes sense to use inheritance here. They can both be abstracted to present a common behavior by having an interface (say asset) and making them implement it.Advantage: Both can present common behavior. Code for common functionality can be reused.Disadvantage: May violate LSP, does not follow natural reasoning. A change in the parent class may have intended consequences of the child.",Responsibility1: addStock()Collaborator1: StockResponsibility2: removeStock()Collaborator2: Stock,"class Exam2    def method_missing(id, *args)        puts #{id} is not defined        puts Hello from #{id}        eval %Q?             def #{id}                puts Hello from #{id}            end            ?    end ende = Exam2.newe.sayHelloe.sayHello",Horse::eat() overrides Animal::eat()Horse::eat(String) overloads Horse::eat(),"Horse eating hay.Since a is declared to be an animal, but is actually a horse, at run time, we search for a method with signature eat() starting in Animal. We do find one, and now we look for a specialized one with the same signature. We find a specialized one in Horse. So Horse::eat() gets called.",Yes. Declare them to be final.,[E] + merge(O) = EO,"[X] + merge ( L[A], L[B], L[C}, ABC) = [X] + merge ( AO, BO, CO, ABC) = XABCO","[Z] + merge (L[D], L[A], DA) = [Z] + merge (DO, AO, DA) = ZDAO","[Q] + merge(L[X], L[Y], L[Z], XYZ) = [Q] + merge (XABCO, YDBEO, ZDAO, XYZ) = QXYZDABCEO","The design pattern is 'Strategy'. It is useful in cases when we have a number of objects of the same type and functionality, yet the way their implement their functionality varies. So, instead of implementing the functionality in the superclass and having each object override for specialization, we convert to functionality to a 'has-a' relation. We implement a number of functionalities that implement a functionality interface, and assign each object their specific functionalities.","Advantage: Making a change, requires a change only at a single place, none of the other objects are affected by a change.Disadvantage: Common functionality is repeated across different implementation of the interface""Manoharan, Ashwanth",,,,,,,,,,,,,,,,,,,,,,,,,,"Mario Dsouza, Navin",,,,,,,,,,,,,,,,,,,,,,,,,,"Maroo, Abhishek",If Java used actual type of the arguments to decide which of the several methods to execute then we could have stopped by just having a single compare method in Comparator Class which is taking Object type as the parameters. We would not have progressed further and made Comparater as Interface and have seperate class for String and Interger comparisions. A single class with a single method would have solved the problem for sorting different data types.,preconditions which are weak and post condition which are as strong.This is because it will increase the range of the value,ORM - Object Relational/Relation Mapping/Modelling,PLA  - Principal of Least Astonishment,Inheritance.,Liskov substitution principle,A lot of functionality is put in the single method. and Encapsulation or data hiding. Data members of this class are not private.,Low Cohesion and High Coupling.Anyone outside the class can modify/access the data.Data is not secure.,"Make the data members as private.According to style guidlines a method should do only one thing and do it well.static shape formNewCircle (double area, double x, double y)static shape formNewRectangle (double area, double x, double y)static shape formNewCylinder (double area, double x, double y)",Yes. If they were system defined classes then depending on the type we could instantiate the class by passing its constructor the inshape.,"portfolio, stock, tax, term, record, Bond",current price because it will be a primitive (int or double).position because it is just a quantity of stocks.,portfolio has stock,position - expressed as quantity of particular stock.A quantity also expressed as a certain number of shares.,Bond can be a sublcass of stock.Yes it makes sense as Bonds are almost similar to that of Stocks but insted of paying dividend they pay interest.The advantage will be of code reuse.,addStock - StockdeleteStock - Stock,"class Exam2  def method_missing (meth, *args)    str = meth.id2name    puts #{str} is not defined    puts Hello from #{str}    Exam2.class_eval do    define_method meth do      puts Hello from #{meth}    end      end  endend",method1 overrides method0method2 overload  method1,Horse eating hay.It is due to the dynamic binding or Run  time polymorphism.,Yes. By making the horse class as final.Or by making method1 and method2 as Final.,EO,XABCO,ZDAO,QXYZDABCEO,"CRC,In this each class has it's own resposibility.",Cleaner Design/interfaces."Muppalla, Preeti",Sorting problem in java could be simplified if we used the type of the argument by not having the abstraction that we created for String and integer Comparator. If Java could understand based on type of argument then we could just have a comparator class like we had after the first modification in class. The reason we couldnt go ahead with that was we got a type error as java cannot understand type of argument based on arguments sent. Hence we needed to make it generic and have String and Integer comparotor have it being extended.,it is better to write post conditions that are strong and pre conditions that are weak  cause is pre conditions are strong it will be difficult to achieve correctness if initially only we have stringent rules and opposed to having strict post conditions that will help overcome and get better correctness.,getter setter methods,command pattern,yo-yo,inheritance,The method name is too big and we have declared method as private.,as it is private no method outside this class can access this  method.,make private to public.,if they are system defined then there is no need as we will be using them indise the class only like the Math we used here.,"portfolio,position,shares,value,","purchase price,current price, These need not be two separate classes. we can have one class called price which has variables purchase price and current price of stock.as both typically represent the price of one particular type of stock we can have two attributes doing the same and have getter and setter methods for these.",Gain can be a super class. The way a gain is calculated is the same but the gain can be short-term or long-term. so the subclasses can be short term and long-term .,earnings is used ambiguously. Earnings is calculated based on gain+interest+.. Nd it is also used to calculate return.Earnings is part of the portfolio calculation.,"Gain can be a super class. The way a gain is calculated is the same but the gain can be short-term or long-term. so the subclasses can be short term and long-term .Yes subclassing makes sense as there will be no code reuse happening,so it makes sense.","PortfolioRequirements: calEarnings             gain,value,dividend,share                     quantity of stock       shares,position",e=Exam2.newe.class_eval do  define_method :Hello(str) do  puts Hello from sayHello  endend  def method_missing(method)    str = method.id2name    puts str    puts (not defined)    Hello(str)  endende.new.sayHello,method1 overrides and method2 overloads.,Horse eating Hay,"yespublic class Horse extends Animal{public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }}",EO,XABCO,ZDAO,QXYZDABCEO,This is strategy pattern.As we are following some sort of strategy here  to perform printing successfully or not.We doing the print operation and if it happens successfully we have a strategy and if fails we have one too.,Due to strategy pattern we get more flexibility.Disadvantage is that you have more object to deal with."Nagasrikantan, Pranamshankar",,,,,,,,,,,,,,,,,,,,,,,,,,"Neelakantan, Aishwarya",,,,,,,,,,,,,,,,,,,,,,,,,,"Pai, Sarvesh","If Java were to use actual types of arguments, we would have directly defined seperate classes for each comparison depending on the type of the arguments.We could have defined StringComaprator and IntegerComparator. After directly invoking objects of these classes, we could have easily got the sorting",preconditions that are as weak as possible.strong postconditions,Object Relationship Model,Principle of least astonishment,yo-yo effect,Liskov Substitution Principle,Function checks for each type.,Because there are too many conditions which depends on the number of type variable passed to the method.,public Square giveSqaure(float area)public Rectangle giveSqaure(float area),Yes.,"Position, Stock, Portfolio, Shares","purchase price: Because it is of a primitive type.earnings: Because, it is plural","Porfolio- Position, where a Portfolio is a set of stock Positions.",,,,"class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined    addmethod  end  def addmethod    Exam2.class_eval do    define_method :sayHello do      puts Hello from sayHello    end      puts Hello from sayHello  end  endende = Exam2.newe.sayHelloe.sayHello",Method eat() in Horse class overrides the eat() method in Animal classMethod eat(String s) in the Horse class overloads the eat() method in the Horse class.,"Output: Horse eating hayThe object a is of declared type 'Animal' but is actually an object of type Horse.When we call a.eat(), it looks into class Animal for a function eat() and finds one. And then it narrows down to the overriden method eat() in class Horse.","Put a final keyword in both the methods definitions.class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }     public final void eat() { //method 1        	System.out.println(Horse eating hay );       	     }     public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}",EO,XABO,ZDAO,QXYZDABCEO,The design pattern used is Adapter. Class PerformOperation serves as a wrapper class for the the print operation and the interface.,"Pandit, Girish",If Java used actual arguments then we could invoke the appropriate method based on argument rather having to check of types and do the necessary type conversion as we did in class,a) strong precondition makes program correct regardless what it doesb) make postcondition as weak as possible,Active Record,Principle of Least Astonishment,yo-yo effect,Liskov substitution principle,It violates the rule that it tries to calculate everything in  one function,Its not a good way to implement a method that does all functionaility,we can have methods like Shape getShape()Shape CalculateNewShape()etc,No then we will have to rewrite those classes which should be avodied,"Portfolio, Stock, Record, Bond","purchase price and current price: These are not key abstraction, rather they are attributes of stocks hence they should not be implemented as classesEarnings is something that is calculated by class Portfolio based on gain interest and dividend and is returned by some operation in portfolio so hence it is not class as well.",Portfolio is aggregation of position i.e. many positions make a portfolio.,position is used ambiguously as it is not clear from the specification whether its should be an individual entity or should be a instance of stocks since it is stated that position is quantity of stocks,Bonds can be subclass of Stock. The reason being:a> It has all properties of Stockb> it only needs to override the returns implementation where instead of dividend it will return interest.Advantage: Less amount of LOC Implementation of Polymorphic behavior between classes.Disadvantage: It will override the returns defination of Stock so a declaration likeStock sb = new Bond() sb.returns()will always override method in Stock even if we might need it for some use.,"Responsibility:know number of positions Collaborator: noneResponsibility:total_return Collaborator: Record, StockResponsibility:total_earning Collaborator: Stock",class Exam2  def hello(str)    puts Hello from #{str}  end  def method_missing(method)    puts #{method} is not defined    str = method.id2name    hello(str)  endend,method1 overides method0i.e. public void eat() in Horse overrides public void eat() in Animalmethod2 overloads method0public void eat(String s) in Horse overrides public void eat() in Animal,o/p:Horse eating HaySince a is of type Animal lookup for eat() starts in Animal then since  a is declared to be of type Horse specific implementation is searched in Horse and hence method1 is executed from Horse class,Declare a to be of type Animal likeAnimal a = new Animal()then if we do a.eat();o/p will be:Generic animal eating generically,"L(E) = E + MERGE(O,O)=EO","L(X) = X+ MERGE(L(A),L(B),L(C),ABC)=X+MERGE(AO,BO,CO,ABC)=XABCO","L(Z)=Z+MERGE(L(D),L(A),DA)=Z+MERGE(DO,AO,DA)=ZDAO","L(Q) = Q+MERGE(L(X),L(Y),L(Z),XYZ)=Q+MERGE(XABCO,YDBEO,ZDAO,XYZ)=QXYZDABCEO",Command Pattern,Advantage: Requested object neednt know who the intended receiver is.Disadvantage: Can clutter up by creating lots of classes unnecessarily."Paruchuri, Avanindra",,,,,,,,,,,,,,,,,,,,,,,,,,"Patil, Akshay",If Java used the actual types of arguments to decide which methods to execute then we could only have one sort method to take the types of arguments  and then use a comparator to compare using the types.,1)we would like the precondition to be as weak as possible because it describes the input routines as general way as possible.2) we would like the post condition to be as strong as possible because they describe the output as narrow as possible.,Object - relational mapping . (ORM),principle of least astonishment,yo-yo effect,Liskov  substitution principle.,"It has too many code as the class is handling cases for all shapes. So, readability will be problem if the shapes are a lot",Because there is too much code in one class and it will be increase if there are many shapes to be handled and thus too much of code is there in a single class.,We can implement the stratefy pattern by depending upon the outshape we call the appropriate class. i.e. class Circle(Shape Inshape),Yes we could rewrite the code to follow style guidelines. We could make them individual classes and then the proper class will be called by creating the proper object which is to be created or returned.,StockPortfolio ManagerRecordPortfolio,1) Position :- it is just an attribute of the stock representing the quantity.1)Dividend (there are no attributes associated with it and it is stock uses method calculatedividend )2) Earnings (it is just a sum of gains and interest and dividends and does not have special methods or attributes of its own used to calculate earnings.),Holdings has parts of the stocks and bonds.,Gain term is used ambiguously in the requirements. It is used in the senses like negative gain and positive gain and then calculate gain. It is used in calculating the tax and the earnings making it key for the system.,"There are Bond and Stock classes that can be a subclass of Holdings. Yes it makes sense in defining the subclases because they same attributes of holdings like purchase price , gain but have different behaviour like stock has pay dividend while bond has pay interest.Adv:- DRY principleDisadv:- we have to associate with them differently. Hence we have to store both stock and bond seperately.",Requirement:-  removeStock    Collaborator :- StockRequirement :- get number of shares Collaborator :- StockRequirement:-  addStock    Collaborator :- StockRequirement:- generate record  Collaborator:- Record,class Exam2      if self.respond_to?#{meth}          puts Hello from #{meth}     else       puts #{meth} is not defined       class << self            def #{meth}           puts Hello from #{meth}           end        end    endend,1)method 1 overrides method 02) method 2 overloads method1,Horse eating hayIt will search in Animal class for the closest matching signature which it gets as method 0 . Then dynamic binding will search down for specific match and finds method 1.,You can avoid the method to be overriden by declaring it as final.,EO,XABCO,ZDAO,QXYZDABCEO,Strategy Pattern.  Depending upon the strategy (which is the print operation) the correct method is called of the strategy object (which is success or failure),1) Adv:- The strategy pattern reduces the amount of code by separating strategies into classes and calling them at run time2) Disadv:- This pattern can produce lots of classes if there are lots of strategies."Patil, Lohit","If actual types of arguments were used to decide which methods to execute in JAva, then we could design the sorting algorithm based on the parameter types. Say we might want to use Insertion/Bubble sort for sorting Integer arrays less than 10000 in size & use something like Mergesort/Heapsort for sorting large Integer arrays or even Double/real arrays.Matching it would be easier but may be overriding it would be harder because the first matched signature would be condsidered.","a)Preconditions should be as Weak as possible.E..g  {x>=9} x=x+5 {x>=13}In above case, we can see that the precondition is not weak enough.We know that if x>=9, then  x+5 will definitely be >=14. So, we can weaken the precondition to make it the weakest by making the precondition as {x>=8} so that correctness is achieved.Preconditions should be the obligation of the client which benefits the supplier in a way that the supplier need not check the preconditions.This faciliates the Programing by contract notion.b)Postconditions should be as strong as possible.Same E..g  {x>=9} x=x+5 {x>=13}Here, we can see that post condition is not that strong. We can make it the strngest by making it as {x>=14} because we know for sure if x>=9, then x+5 will be >=14. So, postcondition should be the strongest here to achieve correctness.Postconditions should be the obligation of the supplier so that client gets benefitted by not checking for the postconditions.This faciliates the Programing by contract notion.",ActiveRecord,Principle of Least Astonishment,Yo-Yo effect,Liskov Substitution Principle,"makeOneShapeFromAnother() is a private method & a static method. So, it can't be called even using the class name. Also, the visibility should be the first in the method signature & then the types.",It can't be called even using the class name.The visibility misplacement will probably thrown an error at compile time.,"the type of the Shape should be an attribute of the subclass of the shape. The type of the shape should not be determined from some external variable.E.g.Class Circle extends Shape{    String type;    //getters & setters for type}==========We can define sublasses of shape which extend Shape, like Circle, Rectangle &Cylinder  & then pass the appropriate parameters like width, radius, etc to the constructors of this subclass.//Class Circle extends Shape{     public Circle(Integer radius){      ///do something    }}Similarly  for  Rectangle & cylinder.","no.It would be better if Circle , Rect & Cylinder extend Shape or may be Shape an interface & make Circle, Rect,etc implement this interface.","Stock, Portfolio, Record, Bond",earnings is not a key abstraction  as it is something which needs to be calculatedValue is a literal i guess. It can't be a key abstraction.,"Portfolio--- it traks Bonds & StocksBond-> purchase price, current price, gain/loss",position is being used ambiguously.One means number of stocks& the other is how long the positions were held meaning how long the stocks were held determines shot term longterm gain.position as  number of stocks is a key abstraction. It should be attribute of stock.,"Parent: Positionmembers: purchase price, current priceSubclass: Stock , Bond (gainOrLoss).Advantages: members purchase & current price can be stored in the parent class called PositionStock can have method called payDividends()Bond can have payInterest().Diadvanteges: ANy methods of Position will be made accesible to both.Also, A stock cannot be converted to a Bond or viceversa. We may use delegation in that case.","Portfolio                                           CollaborateorsResposibility: CalculateTotalEarning()   Stock, BondgenerateTax()                                     Stock, User","1.def method_missing(meth, *args)p #{methis not defined.end2.e = Exam2.new e.class_eval do  define_method :sayHello do  puts Hello from  sayHello  endend3.e.sayHello","Overrides: In the Horse class, method 1 eat() of Horse overrides method 0 eat() of the Animal.Overloads: In the Horse class, method 2 eat(String s) overloads the method 1 eat() of Horse.","Output: Horse eating hayHow:1. Since the declared type of 'a' is Animal, it matched the eat() method 0 of animal.2. Then it drills down the hierarchy to check if there is another method with exact signature(& there is actually, method 1 in Horse)3. So, it invokes the eat() method 1 of Horse.","We can us the keyword final to do that. final keyword prevents method from being overriden by the derived classes of Horse.public class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }     public final void eat() { //method 1, also notice keyword final        	System.out.println(Horse eating hay );     }     public final void eat(String s) { //method 2, also notice keyword final       	System.out.println(Horse eating  + s);     }}","E+merge(O,O)=EO","X+merge(AO,BO,CO,ABC)=X+ABCO=XABCO","Z+merge(DO,AO,DA)=ZDAO","Q+merge(XABCO, YDBEO, DAO, XYZ)=Q+XYDABCEOZ=QXYDABCEOZ","Command pattern is being used here.Here, we don't know whether to print Success or Failure but we have already created an object(command) which will do that. When we decide as to whether to print Success or Failure, we initiate the appropriate action & the specific command gets printed.It decouples the object that invokes the operation from the one that know how to perform it.",Advantage:1. It encapsulates a specific action. 2. The main advantage of the command design pattern is that it decouples the object that invokes the operation from the one that know how to perform it.Disadvantage:  1.it results in lots of little Command classes that can clutter up a design"Prakash Rajagopal, Surya",If the actual types of the arguments,"In case of (a) if the preconditions is as weak as possible then, the over head is with the supplier of providing the correct solution to the weakest precondition. In this case the postconditions has to be made stronger. In case of (b) if the postconditions is as weak as possible then, the over head is with the client of providing the correct input to the weakest postcondition. In this case the preconditions has to be made stronger.",MetaProgramming.,The Principle of Least Astonishment,Yo-Yo Effect.,Liskov Substitution Principle (LSP),Inheritance.,The concept of minimizing the code-reuse is violated.,"The style guidelines says to make use of the inheritance, interfaces and polymorphism concepts to rewrite the code.public int equals(String type, Shape inshape)",If these were sys-defined classes it'd be a bad idea to follow the style guidelines as it might interfere with the entire system libraries.,"Portfolio, Record, Price, Value, Stock, Bonds","Position, Earnings. Position defines the quantity of the stock, hence it can be used as a variable. Earnings are calculated from different quantities and it defines to be a variable.",Stock contains the Gain object.,Stock has defined by two different quantities,Value can  be sub-classed into Gain or loss. This done to ease the tax operations calculations on long term and short term gains.,"Class :PortFolioResponsibilities                                                                      Collaborator(s)1.Adding Stocks                                                                        Stocks2.Calculate Earnings                                                                  Stocks, Bonds","class Exams  def method_missing(meth, *args)    puts  #{meth} is not defined  endende = Exams.newe.class_eval do  define_method :sayHello do  puts Hello from sayHello   endende.new.sayHello",Method 1 over rides Method 0. Method 2 overloads Method1.,"Horse eating hay. The over ridden method  (method 1) matches the type as determined during the compile time and by dynamic method invocation, the method1 is called","Adding final modifier in both the methods prevent over riding.public final void eat() { //method 1        	System.out.println(Horse eating hay );     }     public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }",EO,XABCO,ZDAO,QXYZABCEO,Strategy pattern is implemented in this code. The strategy pattern is used to determine which implementation is needed to implemented depending upon the input of the task assigned.,"Advantgae:1.Encapsulating the algorithm in separate Strategy classes lets you vary the algorithm independently of its context.2.The Strategy pattern offers an alternative to conditional statements for selecting desired behavior. When different behaviors are Encapsulating different behaviours in different Strategy classes eliminates the need for conditional statementsDisadvantage:1.Strategy pattern increases the number of objects in an application.2.A client must understand how Strategies differ to be able to select the right strategy. If possible, the context may be able to do this for you.""Rafiul Hussain, Syed",,,,,,,,,,,,,,,,,,,,,,,,,,"Raghavan, Prashanth",,,,,,,,,,,,,,,,,,,,,,,,,,"Raj Thirumurthy, Rohit",,,,,,,,,,,,,,,,,,,,,,,,,,"Ramana Sai Malladi, Venkata","If java had used actual types of arguments to decide, we could give an implementation for sort method in the actual superclass of the classes. Then, we need not implement this method in each of the subclasses that inherit from this superclass. when we make a call, instead of going to the actual class, it sees the declared class and goes to the method implementation defined in our superclass.","by making the pre conditions weakest and post condition strongest, we will make best use of the code we write. This will help the code be correct in more scenarios. But, just because we have a stronger precondition or weaker postcondition, the code doesnot become completely incorrect.",object relational mapping,principle of least astonishment,yo-yo effect,Liskov substitution principle,it violates A method should do only one thing and do it well. make the code readable. so many lines inside if else loops can be removed and method calls can be placed instead of the code directly,the code becomes more and more lengthy. it is more O-O to have the method calls in the if else loops,"remove if (type.equals(circle)) {     radius = Math.sqrt(area / math.PI);     outShape = new Circle(x, y, radius); // Assign a circle   }make this asif (type.equals(circle)) {outShape = createCircle(area);}similarly, remove  else if (type.equals(rectangle)) {     width = height Math.sqrt(area);     outShape = new Rect(x, y, width, height); // Assign a rectangle   } make this as else if (type.equals(rectangle)) {outShape = createRectange(area);}similarly remove else {     radius = Math.sqrt(area / (Math.PI * 3));     height = radius / 2;     outShape = new Cylinder(x, y, 0, radius, height);//Assign cylinder   }make it aselse{outShape = createCylinder(area)}","even then,instead of creating the objects if new classes in this method, it is more O-O to call a new method to create object for each kind of shape.","Portfolio,Share,Record,Position","gain- the gain calculation need not be a class because it just calculates the gain incurred by the holder. It can just be a methodposition:current_price- this is a variable that keeps changing from time to time. It is often modified. Also, it is a property of a bond.dividend: it is something related to a particular bond and so should be the variable in a class and not a separate class.",portfolio has a set of stock positions. Thus Stock has an aggregate relationship with the portfolio class.,,"A portfolio is a set of stock positions. this makes us feel that the portfolio could be a subclass of stock positions. But, it is not a good decision because Portfolio can have entirely different responsibilities from that of position",1. know quantity of each stockthis does not require a collaboratior2. control price of  stockthis has a collaborator share,"class Exam2def method_missing(meth, *args)puts sayhello is not definedExam2eval %{  def sayhello; puts hello from say hello; end }endendc = Exam2.newc.sayhello",1. eat() method overrides the eat() method defined in the Animal class.2. eat(String s) overloads the eat() method.,"Horse eating hay is printed here. Because, the jvm looks for eat() method in the declared class of the object which is animal. After this is found, it checks if there is more specialized method with the same signature under it dynamically and since eat() is overridden in Horse class, this version of eat() is implemented.","we can give the method declarations as public final void eat() and public final void eat(String s) to avoid these from being overridden. But, teh eat() method can be overridden from the Animal class anyway.",EO,"X+M[AO,BO,CO,ABC]=XABCO","Z+M[DO,AO,DA]=ZDAO","Q+ M[XABCO,YDBEO,ZDAO,XYZ]=Q+XYZDABCEO=QXYZDABCEO",the code uses adapter pattern. This wraps around the method,"used for solving problems like integration where each time we compute the area underneath, a different formula has to be used.disadvantage: code is sometimes redundant.""Ramanjulu, Navya",,,,,,,,,,,,,,,,,,,,,,,,,,"Ramaswamy, Shyam","If Java used the actual types of the arguments to call the appropriate method, then it would be able to identify at compile time itself which of the methods from the Comparator class to call. Since it knows the datatype of the arguments it will be able to find the method with the appropriate signature and call that method.",It is better to have STRONG PRECONDITIONS and WEAK POSTCONDITIONS. This is because having strong preconditions ensures that you do not pass in spurious values into the method. The onus is on the client to make sure that the input to the method is correct. Weaker postconditions ensure that the method is correct for a majority of time.,Object Relational Mapping (ORM).,Principle of Least Astonishment.,yo-yo effect.,Liskov Substitution principle.,"1) A method is supposed to 'one thing only, and do it well'. This method performs many computations for Circle, rectangle etc. and it should not do this. Thus is is violating the single-responsibility principle which emphasizes on the separation of concerns.2) It statically checks the type using the string type and based on this value, it performs some calculation. The problem with this is that if more types are added over time, then code in this mehtod will need to be changed to add those transformations for those types. This is bad, because it means this class has high coupling and is dependent on the all the types in the system.3) The method name makeOneShapeFromAnother is too long. It should be shorter like transformShape etc.","1) It is bad to violate the principle because then it means that one method/class is responsible for doing many things. When changes have to be made to this method, it will get very confusing and laborious because many changes will have to be made since all functionality (computation) is within this method itself.2) It is bad to violate the rule of having low coupling, because it means the method/class is dependent on some outside factors and  causes a 'ripple effect' i.e. changes made elsewhere will causes things to be changed in this method as well.3) It is bad to have poor naming because it can confuse the programmer.",The code should be rewritten to encapsulate the functionality within each 'if' block into its own method.Shape makeCircle(Shape inShape)Shape makeRect(Shape inShape)Shape makeCylinder(Shape inShape),"If they are system-defined, then the code may break because it is only possible to assign Circle, Rectangle or Cylinder to a Shape object, if they inherit from Shape or implement Shape (if it is an interface). So as long as this rule is followed, you the above code will work, otherwise it will not.",1) Portfolio2) Shares3) Price4) Gain,1)  purchase price and current priceare not key abstractions because they are a type of price and should not have classes of their own.2) short term and long term gain. These are two different types of the gain class and hence are not key abstractions.,Portfolio owns/contains stock positions.Position owns/contains number of shares.,"The key abstraction gain is used ambiguously because there are different types of gains: loss, shot term, long term etc. it is not clear if these types should subclass gain or use delegation.","Gain could be subclassed into ShortTermGain, LongTermGain, Loss etc. The disadvantage here is that this is not very good OO design and may lead to violation of the DRY principle.","Portfolio:Responsibilities:1) Know current price2) Know purchase price3) Calculate earnings4) calculate the total returnCollaborators:1) Gain, Position2) Gain, Position3) Gain, Price4) Gain, Price","class Exam2def method_missing (met, *args)   puts #{met}   eval %{def #{met}   puts Hello from #{met}   end   }   self.#{met}endend",The method public void eat() in Horse class OVERRIDES the method public void eat() in the superclass (Animal).The method public void eat(String s) OVERLOADS the public void eat() method in the Horse class.,"Output: Horse eating hay In a.eat(), a is of type Object, so the search for the method begins in the Animal class. We find the matching signature public void eat() in Animal and drill-down in the inheritance hierarchy until we find the most specific form of this method in the subclasses. There is a match found in the Horse class with the same signature and hence this method is called in the Horse class.",We can make the methods as 'final'.  This prevents it from being overriden in a Subclass. Hence the method signatures in Horse class will become:public final void eat() {...}public final void eat(String s) {...},EO,XABCO,ZDAO,QXABCYDEZO,Command Pattern.The Success and Failure classes are used to store the different 'commands' which may be used later on. Hence this is Command Pattern.,"Advantage:There can be more implementations of IPrint which can be passed to an instance of PerformOperation and it will work perfectly. Thus this design is extensible.Disadvantage:If the print operation has to do more than print (e.g. log the statement/error) for which an additional method is required, then adding this to the interface might break existing code and would also require you to write additional code in the implementations of that interface to define that method.""Ravi Teja Peri, Srinivasa","By  Dynamic binding ,Dynamic method dispatching",Strong Preconditions and Strong PostconditionsBecause they will increase the quality of the constraint.,OBJECT RELATIONAL MAPPING,The principle of least astonishment,Yo yo effect,Liskov substitution principle,method is declared as private,The method cannot be called from outside the class,"public static Shape makeOneShapeFromAnother(Shape inShape, String type) {   Shape outShape;   double area, radius, width, height;   double x = inShape.getXPos();   double y = inShape.getYPos();   area = inShape.area();   if (type.equals(circle)) {     radius = Math.sqrt(area / math.PI);     outShape = new Circle(x, y, radius); // Assign a circle   }   else if (type.equals(rectangle)) {     width = height Math.sqrt(area);     outShape = new Rect(x, y, width, height); // Assign a rectangle   }   else {     radius = Math.sqrt(area / (Math.PI * 3));     height = radius / 2;     outShape = new Cylinder(x, y, 0, radius, height);//Assign cylinder   }   return outShape;}","No you cannot because no more you can pass as parameters Shape inShape, String type inprivate Shape makeOneShapeFromAnother(Shape inShape, String type)","Portfolio manager,Portfolio,Position,Record,Share","purchase price,current price are  not the key abstractions because they can be maintained as instance variables of primitive types. Therefore they should not be implemented as classes","portfolio,postion",gain and loss .It would have been better if they would have names it like returnFromStocks.,"portfolio ,positionstock,share",Responsibilities:has to  maintain the positionskeep track of a set of stock or bond holdings.should buy stocks.Collaborator:positionsharestock.,"class Exam2def method_missing(method, *args)   meth=method.id2name   puts #{meth} is not defined  self.class.class_eval do     def meth        puts hello from sayHello      end  end  self.methendende = Exam2.new e.sayHello e.sayHello",method 1 in the Horse class overrides the   method0 in Animalmethod1 and method2 are overloaded methodsmethod 2 overloads method 1,It prints Horse eating hay First during compile time it selects method0 in Animal ..During runtime it will select method1 in Horse as it is the overriding method,methods 1 and 2 in horse are not over ridden,EO,XABCO,ZDAO,QXYZDABCEO,Strategy pattern,-Hierarchies of Strategy classes can be used to define a family of algorithms or behaviors for contexts to reuse.-Encapsulating the algorithm in separate Strategy classes lets you vary the algorithm independently of its context.disadvantageStrategy pattern increases the number of objects in an application."Reddy Anumula, Jyothi","We has a problem when sort takes an object[] and comp has overriden methods like compare(String s1 , String s2) and compare(int a, int b).If java uses actual types of arguments also just like CLOS then this problem wouldn't arise as sort would take an argument of Object[] and passes the objects(strings or integers) to comparator. Comparator takes the objects and based on the type of the object the corresponding method is called. For exampe if we try Sort method on Strings then Sort function takes String array as object array and then passes it to Comparator compare function. The appropriate compare function (compare(String s1 , String s2)) id invoked based on the actual type of the argument passed.",preconditions strongpost conditions weak.,,Principle of least astonishment,Yo Yo effect,Liskov substitution principle,using type of the object and then performing actions based on it. A good o-o style doesn't follow the above coding convention.We can use polymorphism instead.,Violating this rule is bad as the code is not easily extensible.,"Use ploymorphism so that based on attributes proper method can be called.We can have classes for Circle , Rectangle , Cylinder as subclasses of shape and pass the Object as Shape to makeOneShapeFromAnother()In makeOneShapeFromAnother() we can have function outShape.which performs shape specific function.outShape(Circle c)outShape(Rectange r)outShape(Cylinder cy)",This would work and all that we have to do is to pass the base class of these classes to makeOneShapeFromAnother() function and in based on class type appropriate outShape is called.,"Portfolio , Stock , Dividend , Gain",shares - as it just represents the quantity.purchase price and current price- These are primitives by themselves and cannot be represented as classes.,All Bonds are Stocks... So Stock Objects own all the Bond Objects.,A portfolio is a set of stock positionsBonds in the portfolio manager can be treated like stocks;The Requireents specification says that portfolio has only stock but in the last line it again says that it also has bonds which are like portfolios.,"Short Term and LongTerm can be subclasses of Term. Term can hold shared properties while short term and long term gains and taxes can be calculated separately.Adavnatges of subclassing:We can have common properties for long term and short term like setting prices, setting taxes etc. The only difference is in calculating the taxes and profit. These can be overriden in subclasses. (same behaviour for both classes).","addstock() collaborators - StockcalculateGain() - Stock , Gain","class Exam2def method_missing(meth, *args)puts #{meth} is not defined eval %{def #{meth} Hello from #{meth}end}self.call(meth)endend",method 1 overrides method 0 method 2 overloads method 0,Output is:Horse eating hay It prints out the above statement as we call a.call() in main and dynamic invocation causes to eat() function in Horse. (overrides eat() in Animal),we can make Horse class as Final so that no classes extend it,EO,XABCO,ZDXABCO,QYZDXABCEO,Strategy pattern,easy to invoke app pr"Reddy Malipatel, Harshavardhan","If the actual type of arguments are used in deciding which method to invoke in run time then we can write compareTo method in each class that is String, Integer and etc and then pass array of objects then call compareTo method on the that class object.",A weak preconditions and strong postcondition helps achieving in correctness. Having weak preconditons and doing defensive programming always ensures that preconditons are maintained irrespective of,Unbound polymorphism,Principle of least surprise,yo-yo effect,Liskov substitution principle,"It violates the principle of code reuse, extensibility and maintainability","that is same code is executed replicated in each of the blocks. It also makes it hard to extend, i mean if a new shape is added then we need to modify above method every time.",instead of having if else blocks for each type we can havea method in each Shape object which takes parameter type and returns back a new shape of that type I mean we should have a method in Shape typeShape transform(String type);,Yes we can rewrite the code by having another class which has a reference to this shape object. and it implements Shape transform (String type) method and it internally uses the reference to delegate and get values.,"Portfolio, Stock, Bond, Record and Share",Current price and purchase price though these are nouns but they represent attributes of a stock. Similarly divident and interest are just values similar to price. Even its the same case with quantity,A porfolio contains many stocks so there is an aggregation relation ship between portfolio and stocks.,Share is used ambiguously. In some cases it represents stock while in other cases it represents bonds. portfolio has many shares,"A share can be either a stock or bond and clearly there is an is a relationship and also each share uses same code and attributes like current price and purchase price and each has a method to find the difference between them and Finally, when calculating net returns these two classes can be used polymorphically. So it satisifies all the conditions to have inheritance relationship",Two responsiblities of portfolio class are totalEarnings and removeAstock and addAstock. For the above responsiblities following collaborators are required. Stocks and Bonds and ProtfolioManager.,#!/usr/bin/rubyclass Exam2endclass Exam2   def method_missing (*args)     puts #{args[0]} is not defined     meth_name = args[0].id2name     meth_name args     self.class_eval do         def meth_name            puts Hello from             print args[0]         end     end   endende = Exam2.newe.sayHello,Horse class void eat() method overrides Animal class void eat() method.Horse class void eat(String s) method overloads Horse class void eat() method.,The output of the program is Horse eating hay. Its because void eat() method in Animal class is overriden by its subclass Horse and therefore it dynamically invokes Horse void eat() method.,"We can prevent overriding of a method by declaring it as final method. This ensures that subclasses can never override it. So in the given scenario public class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }public final void eat() { //method 1        	System.out.println(Horse eating hay );     }     public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}",EO,XABCO,ZDAO,QXYZDABECO,It uses strategy pattern based on the IPrint type configured the corresponding IPrint implementation invoked.,This pattern allows new type of prints to be added easily without modifying Perform operation class. On otherhand it allows only one print operation to be executed at any point of type we cannot print multiple print methods at a time"Reddy Vellanki, Sindhoora","If the actual types of the arguments were used to decide which of the several methods to execute, then the compiler would know which method to call based on the actual type. There would be no need for an interface and arbitary objects could be sorted using the same sort method.","A precondition should be strong enough that the program is correct regardless of what it does. Similarly, things can be made easy for the program by making the post condition as weak as possible.",Active Records,Principle of Least Astonishment,"Yo-Yo effect, which is a drawback of inheritance.",Liskov Substitution Principle.,"Principle: A method should do only one thing and do it well. The method here does three things.There is no modularization. The code related to circle, rectangle and cylinder has been put into one function. Any change to one of these shapes, would affect the others as well.",It leads to putting in too much of code into a single method and any change to one of those requirements needs modifications to the entire method affecting other functionalities also.,"areaCircle(){....}areaRectangle(){....}areaCylinder(){...}static private Shape makeOneShapeFromAnother(Shape inShape, String type) {    Shape outShape;    double area, radius, width, height;    double x = inShape.getXPos();    double y = inShape.getYPos();    area = inShape.area();    if (type.equals(circle)) {      areaCircle();    }    else if (type.equals(rectangle)) {      areaRectangle();    }    else {       areaCylinder();    }    return outShape; }","Yes, we can still re-write the code to follow the style guidelines. If there are system - defined classes, we can always call the methods in those classes to fulfill the desired function, instead of writing the code again into our method.",1. Portfolio.2. Record3. TotalReturn4. PortfolioManager,"1. Purchase price and Current price are not implemented as classes, because they are primitive types. Classes do not have to be written to implement their functionality.2. Loss is not implemented as a class, because its functionality is redundant.",Earnings and dividend form an aggregation relationship as earnings is defined to be made up of gain + interest + dividends.,,,"1. Responsibility: Update the position of the stock.Collaborators: Position 2. Responsibility: Furnish the total earnings and returnCollaborators: PortfolioManager, Record","class Exam2def method_missing (meth, *args)puts #{meth} is not definedendExam2.class_eval dodefine_method :meth doputs Hello from #{meth}endendende = Exam2.newe.sayHello",public void eat(String s) overloads the method public void eat() in the Horse class. public void eat() method in Horse Class overrides the method public void eat() in Animal Class,"Output: Horse eating hayThis is due to dynamic method invocation. The subclass Horse overrides the eat() method of the Animal Class. The object a is of declared type Animal. a.eat() matches the eat() method in Animal class and then a drill - down occurs to check if the subclass Horse has a specialization of it. Here, Horse has overridded the eat() method. So, this eat() method of Horse class gets invoked. Hence, the output of Horse eating hay.","In Java, to prevent methods from being overridden, use the final modifier in the method declaration, which implies that it is the final implementation of the method. Below is the code to do it:public class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }     public final void eat() { //method 1        	System.out.println(Horse eating hay );     }     public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}",EO,XABCO,ZDAO,YDBEO,This is an example of the Command Pattern.,The Command Pattern helps us elegantly implement closures. It successfully decouples the object which invokes the operation from the object which actually performs the operation. The major disadvantage of the pattern is that it results in lots of little Command classes that can clutter up a design."Shah, Dhara","The sorting method can be simplified by creating a generic sort routine that would take two objects as parameters which are of the Object type. Here we use the Object type since Object is the superclass of String, Integer and all other classes in Java. Thus, we eliminate all compare methods and replace with a general method which is enough to deal with all the cases. We define separate comparators for each type of data and hence avoid the problem of which method to execute.","To help achieve correctness, writing strong preconditions and strong postconditions is a better measure since it will allow more specification and hence, when one is trying to achieve the correct solution, the stronger the conditions, the more possibility to achieve correctness. For example, if we have, {x>=9} x = x + 5 {x>=13}here for the given precondition, the postcondition is not strong and hence to achieve correctness, the post condition should be more tight, {x>=14}",,Principle of Least Astonishment,The yo-yo effect,Inheritance,A method should do only one thing and do it well.,It is bad to violate this rule because the method at once should not return a value and also modify the state of the object at the same time.,"The possible way to get around this problem is to make separate methods for each type of function that is to be implemented and not return a value and change the state at the same time. Hence, for this example, we can create a separate Shape method which can be defined abstract and it has subclasses for each shape that is to be drawn, like Circle, Rectangle and Cylinder.","If Circle, Rectangle and Cylinder are system defined classes, then we should not rewrite the code to follow these style guidelines. This will lead to code duplication. Instead we should inherit the methods and override the methods which we want to implement separately.","portfolio, share, total return, earning",1) tax is not a key abstraction since it is calculated on the gain and hence it should not be implemented as a class.2) purchase price and current price are not key abstractions since they are constant and defined when a stock is bought and its value at current time for a particular stock and hence they should not be implemented as a class.,"An aggregation relationship here is that of a portfolio contains various stocks and has a set of stock positions. Hence, the aggregate is portfolio that contains stocks.","Gain is a term that is used ambiguously in the requirements. The different senses in which gain is used is given below:1) The gain is defined as the difference between the value of the stock when it was bought and its current value.2) A negative gain is called a loss.3) Depending on how long the position was held, the gain may either be short term or long term. This matters, because short-term gains and long-term gains are taxed at different rates.",There is no necessity to subclass a relationship here. The advantages of subclassing would lead to code reuse but the major disadvantage would be that each classes have their own implementations and hence wouldn't use much of the superclass methods.,Class PortfolioResponsibilities - Collaborators:1) Add a stock to the portfolioCollaborator - Share2) Calculate the total earningsCollaborators - Share,"class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined.  end  eval %{def sayHello     puts Hello from sayHello     end}  Object.class_eval do    class << self      def attribute_accessor(*instance_variables)        instance_variables.each do |instance_variable|        class_eval %Q?          def #{instance_variable}            @#{instance_variable}          end          def #{instance_variable}=( new_value )            @#{instance_variable} = new_value          end          ?        end      end    end  endende=Exam2.newe.sayHelloe.sayHello",The method 1 overrides method 0 of Animal class in Horse class and method 2 overloads method 0 of Animal class in Horse class.,"Output: Horse eating HayThe reason why it prints method 1 is that when we create a new object a, it is declared of type Animal and hence when we start to look for a method that closely matches the defined method, we start our search from the Animal class and we come across method 0 which has the same signature as the defined method. Thus, we look further down in the Horse class by dynamic method invocation to find a more closer match and we come across method 1 which has overridden method 0 and hence we call method 1 which is a more closer match than method 1 since the method called is Horse().",No.,EO,XABCO,ZDAO,QXYZDABCEO,Command Pattern. The Command Pattern is a pattern that it is used to issue requests to the objects.,The advantage of using Command pattern is that it allows addition of new commands with minimum effort. The disadvantage of this pattern is that it results in lots of little Command classes that can clutter up a design."Shah, Jitesh",,,,,,,,,,,,,,,,,,,,,,,,,,"Soundara Rajan, Subashini",,(a) Preconditions that are strong as possible. A strong precondition can ensure a condition and prevent the program from running into errors.(b) Sometimes postconditions donot matter if the preconditions are strong enough to filter out the restrictions. I depends upon the conditions we are applying for the correctness of the program. Either a strong/week precondition or postcondition might favor the scenario. This is problem specific.,Object-Relational Mapping,Principle of least astonishment,Multiple Inheritance,Liskov substitution principle,"A method should perform only one action and it should do it properly.In the above code the method makes a circle,rectangle and also a cylinder.",It is not very clear what operation the method performs. If there is a change to one of shapes that has to be created it might affect the other shapes. For example changing the data type of x with circle in mind will affect all the other shapes.,static private Shape makeCirclefromShape(Shape inShape)static private Shape makeRectangefromShape(Shape inShape)static private Shape makeCylinderfromShape(Shape inShape),Yes we should still be able to rewrite the code to follow the style guidelines even if they are system defined classes. It doesn't matter since it would be a simple delegation.,portfoliorecordtaxgain,"shares - pluralearnings - can be represented as a primitive, need not be implemented as a class",,Gain - The gain is defined as the difference between the value of the stock when it was bought and its current value. loss -  A negative gain is called a loss.Gain represents the key abstraction,"Gain is a baseclass. There are two types of gains here, ShortTermGain and LongTermGain, which can subclass from Gain.",Responsibility:Know stockKnow stock positionCollaborator:Position,"class Exam2  def method_missing(m, *args, &block)    puts There's no method called #{m} here -- please try again.    Exam2.class_eval %Q{                def #{m}                    puts Hello from #{m}                end           }  endende2= Exam2.newe2.sayHelloe2.sayHelloe2.sayHelloe3=Exam2.newe3.sayHello",eat() (method 1 and method 2) are overloaded in Horse class.eat() method 1 of Horse class overrides method 0 of animal class,Output: Horse eating hay.It prints the above output even though a has a declared type of animal. a is actually a type of Horse and due to dynamic binding the eat method in Horse class which is  the more specific method with the same signature is called.,"public class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }     public final void eat() { //method 1        	System.out.println(Horse eating hay );     }     public final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}Methods declared as final cannot be overridden.",EO,XABCO,ZDAO,QXYZCDABEO,Strategy Pattern. You could either print a Successful Operation or a Failed Operation.,Advantage: Using a strategy pattern is extensible and maintainable. We can change the print method without changing the interface.Disadvantage:"Srinivasan, Thothathri",,"Strengthen the precondition, and weaken the postcondition to ensure that the program will be correct, regardless of what the other one does.","Variables' names should mean what they store or do, similar to the names in the db",PLA : Principle of Least Astonishment,The yo-yo effect,Tight coupling of classes and subclasses,"Too many if else's. Also, the name of the method is makeOneShapeFromAnother is too long.","A method should just do one thing, and do it well. This uses type to find out what kind of a shape it is, and then has if else statements. If tomorrow we wanted to add a sphere, we would have to write more code and modify the same method, which should never be done.","For each type of shape, have a method that does that. Should have createRectangle() createCircle(), etc.If else statements should not have much code in it, but should instead have just a method that does the same work. This would make it more readable, and the method names would indicate what the method does. Another better way would be to have an interface and have all these Rectangle(), Circle() extend them.","If they are all system-defined classes, then it might not be needed, as each if else statement would use just hat, unless we plan to keep adding more functionalities, in which case that would be a good idea.","portfolio, shares, current value","purchase price, current price : These are not needed, and the overall portfolio system can be maintained without this as well.","All stocks are owned by portfolios. When a stock is bought, it is added to the portfolio. When sold, it is removed from the portfolio. We can say that this is an aggregation.","current value is ambiguous, as it says it is needed to dscribe the system.However, value of the stock when it was bought and its current value",Gain which can be Shortterm or longterm gain. Gain here would be the base class and shortterm and longterm are subclasses.By subclassing here the advantage is that we can add more later.Disadvantage : not needed if only two are there,"Calculate Gain : stock, quantity",class Exam2def method_missing(meth)puts #{meth} is not defined.c = Exam2.newc.class_eval dodefine_method :meth doputs Hello from #{meth}endendc.new.:methendend,method 1 overrides method 0method 2 overloads method1,"Output : Horse eating hay It prints this because when you say a.eat, the base class matches method0 to this. It doesnt end there. It searches in the derived class if there is a method similar to method0 (Same name as method0, and arguments.)It then finds method 1, so it executes method 1.",,EO,XABCO,ZDAO,QXYZDABCEO,"Command Pattern is used here.In the command pattern an object is used to represent and encapsulate all the information needed(like method name, the object that owns the method and values for the method parameters) to call a method at a later time.","The main advantage of this is that it decouples the object that invokes the operation from the one that know how to perform it. It can be used for undo/redo in editors for instance.The disadvantage to use this is that the code that is doing therequesting doesn?t know what the receiver will be, or what operation will berequested.""Sun, Hao","If java used the actual type to determine the methods to execute,we can make the parameter the object type. So when executed , dynamic bonding will look the entire subclassing diagram to determine  the actual type of the parameter and then invoke that method.","Precondition is as strong as possible to achieve the correctness and the postcondition is as weak as possible to achieve the correctness.  The post condition is better.Think of this scenario, if the precondition need to be examined every time to determine whether the array is sorted or not. It is time-consuming and can be done to meet the postcondition. Another example is that one may not want to first examine the parameters passed in are nil or not, but to add condition in the postcondition if the parameters are nil, and then invoke some error handle to handle it.",adapter pattern,The principle of least astonishment,"know the parent to determine the feature, the number of the parameters and so on, and then do the programming",Liskov substitution principle,The method should only do one thing and do it well. It is really hard to read and understand the logic when developing a large software where in this way the line in one method is too long. There are also many duplicate code there.,"The method should do a lot of work thus make the logic complicated. It is hard for the people to read and understand the logic. In addition,  the duplicated code violates the dry principle which is also bad. Most importantly it is really hard to extend. The extensibility is not that good. If we want to add new type. We need to modify the code in many places.",1.The name of the method is two long. Change it to: Transform_Shape is better.2.Factor out duplicated code.We just need one calculation type to manage different type of the shape calculate_area(Object type)and use public interface to be implemented to manage different type :public interface differ_type(Object type){}public class Circle implement differ_type{},"Yes,just save time and energy to implement the interface.",Stock Portfolio Record Manager Share,"The first one is tax. Because gain can be calculated from other properties, and there is no need to constitute a class just have a tax attribute.The second one is 'purchase price'. Because it is an attribute of stock.",The manager or the person has stocks which can be recorded in the portfolio and calculate the gain.,stock. Because there is a need to identify the interest and dividend.,"The bond which can be a subclass of a stock, but the bond need attribute divined which is different from the interest. The advantage is that the bond can inherit many attributes and methods which saves development time. The disadvantage is not all the methods or attributes are need by the subclass thus leading to the collision.",It need to know its position collaborators: stockit need to identify the term  collaborators:gainIt need,"class Exam2  def method_missing(method,*args)    puts #{method} is not defined.    go(method)  end  def go method    Exam2.class_eval do      define_method :method do        puts Hello from #{method}!      end    end  end  ende = Exam2.new e.sayHello e.sayHello",The method1 overrides method0. Method2 overloads method1.,"It will print as follows:Horse eating hayIn the main function, because object a invoke the method1 which overrides method0, a will call the method1 instead. So the print will be above.","yes, just make them final","E+merge(O,O)=EO","X+merge(AO,BO,CO,ABC)=X+ABCO=XABCO",ZDAO,"Q+merge(XABCO,YDBEO,ZDAO,XYZ)=QXYZDABCEO",It is the strategy design pattern. Process differently according to different condition.,"One advantage is that we can determine the method when the condition is different. In this case, we can identify the success and failure differently and modify the message differently.One disadvantage is that it violates the dry principle. Another disadvantage is that the developer just do the duplicate work as the system dose.""Surve, Prafullakumar",,,,,,,,,,,,,,,,,,,,,,,,,,"Swaminathan, Suraj",,,,,,,,,,,,,,,,,,,,,,,,,,"Udaiya Kumar, Harish","Sort( object[] Array){   // Sort the array}In this case, the invocation to the sort method will invoke the appropriate sort method by looking at whether we are passing an array of Strings or Array of Integers. This eliminates the need for using the comparator since the type of argument is identified at run time.",The Answer is : It dependsWe can achieve or retain the correctness by either making the preconditions strong and post conditions weak or the other war around.,ActiveRecord,Principle of least astonishment,yo yo effect,Liskov's substitution principle,It does not create an instance method. It creates a static method which will be visible to all the classes. In OO programming : Each object should have a well defined behavior and intelligence.,1. It makes the code hard to debug/maintain or understand2. Making changes in one location might have a cascading effect of introducing bugs elsewhere3. It does not support re-use of code.,"Each method must do only one task and do that task well, Static methods must be avoided unless the object is stateless or if the method does not depend on or update the state of the Class. Circle MakeCircle(int x,int y,int Radius)Rectangle MakeRectangle(int x,int y, int height, int width)","Yes, Even if they are system-defined it is necessary to re-write the code so that it makes easier to customize the functionality to be provided by user-defined class that wraps up the system-defined class & methods","Portfolio, Stock, Share, Bond",current price - It can be implemented using a primitive type (double or float or int)short term: - This just an instance of gain and thus should not be a class,A portfolio containing a set of stocks,A share could either mean a stock or a bond both of which different entities. using it as a  Stock - represents the key abstraction.,"The Share class can be made a super class of both the Stock class and Bond class. Justification: The both share the properties: they have a purchase price, current price, and gain (or loss). The method calculateDivident() can be defined in the Share class and Calculateinterest() can be defined in the Bond class. This helps in re-using the code.",Maintain Stock Positions -> Collaborator : Stock Class Calculate gain -> Stock,"class Exam2  def method_missing ( meth, *args)      puts #{meth} is not defined      str = meth.IdtoName      self.class_eval%Q{ def #{str}      puts Hello from #{str}      end       }       var = meth      var.call(args)  endWhen sayHello is invoked the 2nd time, the method_missing() will not be called since the class now has the definition of sayHello from the first call.",void eat() inside the Horse class overrides void eat() in Animal Classvoid eat( String s) in Horse class overloads the void eat() method,output >> Horse eating hayAlthough the declared type of variable 'a' is Animal the variable has a reference to the Horse object. Thus at run time this determination where the object is pointing to is done and the appropriate method is called.,One approach : make both the eat methods in Horse class private in which case it cannot be overriddenAnother Approach : Make the Horse class Immutable.,EO,XABCO,ZDAO,QXZYBCDEAO,The pattern used by the code is strategy pattern,The advantage of strategy pattern is that : it makes the code simple and easier to understand (when you compare it with run-time polymorphism) Disadvantage : The pattern class must enclose all the behaviors within the single class. If there are several operations to be done depending of run-time parameters then this single class must cover excessively large possibilities."Varavani, Jayanth","If the actual type is used instead of data type checking which is generally performed by Java, then we can avoid having a comparator for each data type like the ones we saw. In our example we declared a String Comparator and Integer Comparator. But by deciding based on the RHS value i.e, check if the Comparator C has a value of kind Integer, String or any data type. Then initialize the objects or type cast the values appropriately and then we can perform either arithmetic comparison or a string comparison. When we see on the higher level we have 2 kinds of comparisons one done on characters and one on arithmetic values. So we can have one Comparator Interface and one Class which when invoked initializes its instance variables based or uses wrapper classes of primitive data types to set the vales of the datatype and then in the compare method of the class we can call either a string comparison or arithmetic comparison. This reduces the number of classes and also works as expected.","Preconditions that are strong as possible and post conditions are as weak as possible.It is possible to give a precondition strong enough that the program is correct regardless of what it does.  {False } S {     }Similarly, we can make things easy for the program by weakening the postcondition as much as possible:{     } S {True }",Public interface,Principle of least astonishment,Yo yo effect,Liskov substitution principle,"The method name is long. It can have a smaller one. Also since this checks for the shape and calculates the appropriate classes we can modularize it with each module taking care for a circle, rectangle or a cylinder.","Having long method names, will confuse a hurrying programmer. If the programmer is in very busy working with a class which inherits from another class which has this method then he will tend to make mistakes while calling this method. A smaller method name can be remembered and also when calling multiple times it will be easy and faster. So the programmer need not worry about copying the method name or checking the spelling each time he calls it. If we dont modularize the code then adding new functionality will be difficult and will increase the code size. Also when required we can override the code.","The style guidelines tell we can have modules like after type checking to have static private Shape makeOneShapeFromAnother(Shape inShape, String type) {   Shape outShape;   double area, radius, width, height;   double x = inShape.getXPos();   double y = inShape.getYPos();   area = inShape.area();   if (type.equals(circle)) {     circle(outShape,x, y, area / math.PI)   }   else if (type.equals(rectangle)) {     rectangle(outShape,x, y, area,height);   }   else {     radius = Math.sqrt(area / (Math.PI * 3));      cylinder(outShape,x,y,0,radius);   }   }Each method takes appropriate parameters and will calculate appro.",Yes we can by using overriding principles.,"shares,portfolio,earnings,records, dividends",purchase price and current price is for individual stock so they can be a part of a share class.gain and tax need not be a class since it is stated that records will record the gain and calculates the tax due to gain,"dividend and shares have an aggregation. Since a stock may also pay a dividend. A dividend is not taxed like a gain but is used for total returns. This can be compared to employee, student and person class where any student can be an employee.","Dividends. A stock may also pay a  dividend . A dividend is not taxed like a gain, but it is used in calculating a stocks total return.Bonds in the portfolio manager can be treated like stocks; they have a purchase price, current price, and gain (or loss). But instead of dividends, they pay interestBut I guess we can also consider position since  Each position is a quantity of a particular stock. A quantity is expressed as a certain number of shares",dividends can be a subclass of records. Since a stock might pay a dividend. Yes it makes sense since a dividend must know everything about the stock.,"resposibilities: should know the stock positions and collaborators: shares,positionsresponsibilities: must know weather a short term or long term , purchase price and current price. Collaborators: Shares,earnings,records","class Exam2def method_missing(meth, *args)    puts #{meth} is not defined.  endend",method 1 overrides method 0method 2 overloads method 1,"The output is Horse eating hayThis is because, first the search begins from parent class Animal since the data type is Animal and finds eat but later by dynamic binding, it will search for more specialized method and hence implements eat() of horse.",We can declare both the methods as final to prevent from being overridden in the subsequent sub class.,EO,X+ABCO = XABCO,Z+DAO = ZDAO,"Q+{XABCO,YDBEO,ZDAO,XYZ}QXYZDABCEO",Pattern used is Strategy. The pattern will give the appropriate output based on situation. That is if the operation is successful or failed.This pattern helps when you need to choose an algorithm for a task depending on some ?parameter? of the situation.,Advantage:Polymorphic dispatch coding is very simple. Case statements can become very complexThe code of the strategy's containing class doesn't have to be changed when a new strategy is added.Disadvantage:Increased number of objects."Varre, Vinisha","If the actual arguments is able to find which methods to execute, then instead of creating a new object for another comparator i could write somehting like Comparator compand use it in the sort function.","To achieve correctness, Strong preconditions and Weak postconditions would be most efficient. Example of strong precondition is that precondition being false. Whatever might be the post condition, if the precondition is false, the statement would be true. If the precondition is strong, the statement would execute accurately and it would work with any weak postcondition also.Example: {false} S {true}",Intention-revealing selector pattern,Principle of least astonishment,yo-yo effect,Liskov Substitution Principle,It does not follow the DRY principle. There is redundant code in the if-else blocks.,It is bad to violate this rule because the redundancy code will prevent the code from being readable and easy to follow. It occupies a lot of space on the screen. It would be better to create a common routine for the redundant code and just give one method passing the required parameters.,"If we create a method say assignShape(), then its header would be something like public Shape assignShape(..parameters..)","If the circle, rectangle and cylinder classes are system-defined classes, then instead of rewriting the code we could create objects for each of the classes and send messages to those objects for creating a circle/rectangle/cylinder using the concept of delegation.","The four classes that can be implemented as classes are Portfolio, Stock, Position, Manager, Bond",we cannot take shares as a key abstraction because it is not a  singular noun and we cannot take purchaseprice/currentprice as key abstraction as they are just primitive types(integer type).,The portfolio and set of stock positions.The stock has purchase pricequantity has number of shares.,"Bond and Stock.In the portfolio manager, bond behaves like stock.In all the other cases, it behaves like the stock with a purchase price /current price in calculating gain/loss","Stock can be a subclass of Portfolio as it is a portfolio and is specialized. If it is subclassed, it could get all the features of Portfoli and if it wants to add any other features like keeping track of the stock with other attributes could be helpful. The disadvantage is that of code reuse and there could be some confusion in the code like the yo-yo effect.","Responsibility: keeps track of the stock/bond holdingsCollaborators: Stock, Bond, PositionResponsibility: calculates rate of increase, gain/loss, tax liabilityCollaborators: Stock, Bond,","class Exam2  def method_missing(m,*args)    puts #{m} is not defined'    Exam2.class_eval do         def #{m}          puts hello from sayHello        end    endendend",The eat() method of Horse class overrides the eat() method of Animal class.And the eat(String s) method of Horse class overloads the method eat() in Horse class.,The output of the above program is Horse eating hay due to the dynamic method invocation. The 'a' reference is pointing to the object of Horse class and so during run-time the method of actual class of the object is called and so is the above output.,The two methods in the Horse class can be made private instead of public and hence they will not be exposed to the subclasses.,EO,XABCO,ZDAO,QXCYZDBEAO,"The pattern that is involved here is the Strategy Pattern. Strategy pattern helps when we need to choose any algorithm for a task depending on some specific parameter of the situation. Here in the above program, the setPrintOperation of the class PerformOperation is used to set the Iprint value whether it is referring to Success class or a Failure class using an object. now, when it says print_operation, the respective and required print method is called which illustrated the strategy pattern.","One advantage of strategy pattern is that when there are many algorithms to accomplish a task and the user wishes to perform the task with a specific algorithm, it is easy to do it with strategy pattern.It directs to that particular class to be executed through the interface. One disadvantage is as there are different algorithms coming up, I need to keep adding into the interface which direct it to the required class. We need to keep changing the existing methods.""Venugopal Thirumala Iyengar, Sridevi","If Java used the actual types of arguments to decide which method to call, it would exhibit static tped behavior where the function arguments are checked at compile time. So in that case, the error would be detected at compile time itself and only compatible arguments would be accepted.",Give weak precondition so that the minimum requiremnt is satisfiedPost conditions must be strong to ensure that the code provides correct results,ORM (object Relational mapping),Principle of Least astonishment (PLA),Yoyo effect,Liskov Substitution principle,Tight coupling,"If a new type is to be included, the other cases also get affected and a new if clause will have to be added",The code to compute the parameters should be isolated. An interface can be defined and the implementing individual classes must include the required functionality in them.public interface ShapeType{   int computeDimension()}//Write individual classes for the types that can implement the above interfacepublic class Rectangle implements ShapeType{}public class Cylinder{},Yes. You can still overwrite them by re-opening the class. But we need to ensure that we don't override /overload the method that is already defined in that class.,"portfolio,  position, shares, record, price-both purchase and current price.",gain/loss - this depends on the rate of the shares and do not form key abstractions and need not be implemented as classestotal return - this is a value computed and need not be a class with the noun name.,stock has purchase price and current price.,stockIt is a key abstraction but is mentioned in the requirements ambigouslyThe mission is to keep track of a set of stock or bond holdings is the statement where the noun should have been identified.Bond is also a key abstraction that is mentioned ambigousoly,"Gain----short term----long termHere, gain is the profit a person makes. short term and long term can be subclasssses.Advantages are that each of them have a different tax computed, so the individual instances of these can be used to compute tax accordingly.","Portfolio Responsibilities:                      Collaborators:stores stock positions              position, quantity, sharesstores price                             purchase price, current price","class Exam2 def method_missing(meth, *args)    puts #{meth} is not defined. endende.sayHello// prints sayHello is not definedclass Exam2  def sayHello   puts Hello from sayHello endend","In Horse class, void eat(), which is method 1 overrides method 0 of the Animal class.In Horse class, void eat(String s) which is method 2 overloads method 0 of the Animal class.","Output: Horse eating hayReason: Object a is of type Animal but is declared as a horse object. So, the check for the eat() begins at Animal class. It finds the match for it in Animal class. At this point, dynamic binding comes into picture and it sees that the eat() is overridden in subclass Horse and so that method (method 1 of Horse class) is invoked.",Yes.The methods in Horse class can be declared final using the keyword so that it is not overridden.Ex:class Horse{  public static main...  public final void eat() { //method1   ......   }  public final void eat(String s){ //method 2   ....  }},E,XABC,ZDA,QXYZDABCE,Strategy patternDepending on whether the opertaion fails or succeeds the corresponding function is invoked.,"Advantage of using this pattern is that it is modularized and efficient and handles success and failure cases well depending on the states.However, I do not think it is maintainable as if there is a new opertaion status like intermediate, or in progress or errors found, we will have to add new classes and implement the methods in these classes to print.""Vijayadev, Ranjitha",,"To achieve correctness, we need strong postconditions (b). This is because a program can start execution due to weak preconditions (though it might not have had it been for stronger preconditions). However, we can incorporate failed cases of precondition in postcondition. By doing so, we can ensure that the program responds faster to error and we achieve correctness.",Constructor,Principle of Least Astonishment [PLA],Yo-Yo Effect,Liskov Substitution Principle,"It is checking for each shape type in a separate if-loop. Basic definition of a class says that it should do one thing and one thing properly. Also, the function name is makeOneShapeFromAnother but the function is essentially taking the same shape and returning the same shape. Hence this is misleading.","It is bad because our object oriented code should be clear and the objective of our class should be to achieve one functionality. Also, the name is misleading of the functionality",,,"Portfolio, Stock, Record, Position",purchase price and current price are not key abstractions as they are different values for price. Total return is also not a key abstraction as it's just a numeric value and can be computed in any method.,"Stock acts an aggregate to purchase price and current price. This is because the existence of purchase and current price does not make sense unless it belonged to a stock. Hence, stock owns it.",,"A portfolio is a set of stock positions. This means that portfolio could be a subclass of stock. Also, a stock may also pay a dividend. In this scenario, even dividend could be thought of a subclass of stock.In the first case, it makes more sense to have a delegation relationship between stock and portfolio by letting portfolio have a has-a stock. This is because by Liskov's substitution principle, portfolio would have to satisfy all the restraints of stock class to be it's subclass. For a single common functionality, this is too much to ask. Hence, subclassing is a disadvantage here.The advantages of subclassing is that it allows for code re-use.",Portfolio class:Responsibility :1. Maintain set of stock positions2. Classify the stock as long term or short term based on how long the position was held.Collaborators:Stock,,public void eat() method in the Horse class overrides the method present in class Animal.public void eat(String s) method in the Horse class is overloaded,Output : Horse eating hayThis,public void eat(String s) - method 1 public String eat(String s) - method 2,"E + merge(O, O) = EO","X + merge(L[A], L[B], L[C], ABC)= X + merge(AO, BO, CO, ABC)= X + ABCO= XABCO","Z + merge(L[D], L[A], DA)= Z + merge(DO, AO, DA)= Z + DAO= ZDAO","Q + merge(L[X], L[Y], L[Z], XYZ)= Q + merge(XABCO, ZDAO, YDBEO, XYZ)= Q + XYZDABECO= QXYZDABECO",It's a strategy pattern.,The advantage is that it provides us to choose a particular output based on a set of input conditions. Disadvantage is that it requires us to maintain a large code base in huge projects."Vontela, Shruthi","public static void sort(Object[] data, Comparator comp){		for (int i = data.length-1; i >=1; i--) {		   // in each iteration through the loop			// swap the largest value in data[0..i] into pos?n i			//find the index of the largest value in data[0.. i]			int indexOfMax = 0;			for (int j = 1; j <= i; j++) {				if (comp.compare(data[j], data[indexOfMax]) > 0)					indexOfMax = j;			}			// swap the largest value into position i			Object temp = data[i];			data[i] = data[indexOfMax];			data[indexOfMax] = temp;		}}The problem is that the compiler can?t determine which compare method to call.    Because the Determination of parameters statically in java. It looks at the 2 parameters of compare which are declared as Objects. But there?s no compare method that takes objects as parameters. Hence compiler reports an error.If the actual types of arguments are taken to decide the method to execute. this procedure works fine by calling the appropriate String or integer version of the compare .",Strong post conditions help us achieve correctness.,ORM-Object Relational Mapping.,Principle of least Astonishment. PLA,yo-yo effect.,Liskov's Substituition principle.,Focus should  on objects rather than on data.,It becomes non oo. can act on global data and make inconsistant changes.,,,StockPortfolioBondRecordPortfolio Manager,shares cannot be a class as only singular nouns can be classes.Earnings cannot be a class as it is a value calculated by teh Portfolio manager.,Stock and Portfolio.,Stock Position and Quantity.,Bond subclass of Stocks.,"AddStock()-- StockRemoveStock()-Stock,RecordKnowStockPosition()",class Exam2    end c = Class.newc.class_eval do   define_method :method_missing(method)            puts #{method} is not defined    method11(method)  end    define_method :method11(method1) do  puts Hello from #{method1}  endend,method 1 overrides method 0method 2 overloads method 1 (and method 0 also),Horse eating Hay is the output.The declared type of the object (a) in the method call a.eat() is Animal. So the compiler checks the Animal class to find a method with the signature eat(). It finds a method. But dynamic binding occurs and the more specialized version of eat() ie the eat() in Horse is called .,The methods 1 & 2 of Horse can be declared as final. This prevents the methods from being overriden.ieChange the signatures of the methods as follows   public void final eat(String s)   public void final eat(),"E+merge(L(O),O)=E+merge(O,O)=EO","=X+merge(L(A),L(B),L(C),ABC)=X+merge(AO,BO,CO,ABC)=X+( ABCO)=XABCO","Z+merge(L(D),L(A),DA)=Z+merge(DO,AO,DA)=Z+(DAO)=ZDAO","Q+merge(L(X),L(Y),L(Z),XYZ)  ;L(Y)=YDBEOL(Q)=Q+merge(XABCO,YDBEO,ZDAO,XYZ)=Q+XYZDABCEO=QXYZDABCEO","Adapter Pattern is used.An adapter allows classes to work together that normally could not because of incompatible interfaces.?	It ?wraps? its own interface around the interface of a pre-existing class.   ?	It may also translate data formats from the caller to a form needed by the callee.",An adapter allows classes to work together that normally could not because of incompatible interfaces.?It may also translate data formats from the caller to a form needed by the callee."Wang, Shan","When a method is invoked, the number of actual arguments (and any explicit type arguments) and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked. If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup.","Preconditions that are as weak as possible, or strong preconditions.From the OO guidelines:The external documentation for a method should be sufficiently specific to exclude implementations that are unacceptable but sufficiently general to allow all implementations that are acceptable.Try to make your methods do something appropriate in all cases so that there are no preconditions.",,list of astonishment,,liskov substitution principle,Single Responsibility PrincipleEvery class should be responsible for doing one thing only and doing it well.,"It decreases the readability, maintainability and reusability of the program.","A class should model one concept, and all the methods in the class should be related to and appropriate for that concept. That is, all the responsibilities of the class should focus on the concept being modeled by the class.static private Shape makeCircleFromAnotherShape(Shape inShape)static private Shape makeRectangleFromAnotherShape(Shape inShape)static private Shape makeCylinderFromAnotherShape(Shape inShape)",Yes.We want each class to have high cohesion in that all the class? behaviors and responsibilities are tightly related. The design principle of maximizing cohesion is one of the patterns of GRASP (general responsibility assignment software patterns).,portfoliorecordgainloss,"position is not key abstractions because it is the particular object, there is no reason for it to be represented within the system.value is not key abstractions because it is just a numeric value.",The total earnings (which is defined as gain + interest + dividends) for a portfolio contains the total return (average percentage earnings per year).,earningsit is the incoming for a portfolio,gain and loss could be subclasses of share.The subclassing here greatly increases the reusability of classes and also minimizes the duplication of code.,calculates the tax: gain termcalculate the total earnings: gain interest dividends,public class Exam2{public Exam2(){System.out.println(sayHello is not defined);}public static String sayHello(){System.out.println(Hello from sayHello);}},override: eat()overload: eat(String s),House eating hayBecause the method eat() in Animal is overridden by eat() in Horse.,"public class Horse extends Animal {     public static void main(String [] arg) {    	Animal a = new Horse();           	a.eat();     }     public static void eat() { //method 1        	System.out.println(Horse eating hay );     }     public static void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }}",EO,ABCO,DAO,O,adapter pattern,The main advantage of the Adapter pattern is that it allows the Client to use the Adaptee with minimal modifi cations to either class. The only new code that is needed appears in the Adapter class.A disadvantage of using the Adapter pattern is that you have introduced yet another class into the design and therefore made it slightly more complex."Xiao, Shundan",,,,,,,,,,,,,,,,,,,,,,,,,,"Zeng, Zheng","If Java used the actual types of arguments to decide which of several methods to execute, we should not use the instance of method to put judge the instance of the type in Java. It will save a lot of time and code to do this work.","preconditions that are as weak as possible and strong postconditions. Because if we can consider as more as possible the conditions the our procedure should face, we can handle nearly all the illegal input in our procedure, so the preconditions can be weak.But the  postconditions should be strong, because we should let the guys that who use our program know all the possible input that our procedure how to deal with them.",,,,,The code should not use the type.equals method to compare the conditions to make different elements. It violate one function just do one thing.,It is bad to violate the rule that it make the code hard to read and make the logic not elegant that hard to catch the meaning from the function name.,"We can use the inheritance, polymorphism, or dynamic method to avoid the not elegant judge from the conditions. We can define a base class like Polygon as the super class of Circle, Rect , Cylinder.And introduce the method Draw(Graphic g) in the Polygon class as the abstract method. Circle, Rect , Cylinder should rewrite the Draw(Graphic g) method in their own class.","Yes. Because Circle, Rectangle, and Cylinder may have some same class in their inheritance path, like in Java the Object class. We can define the Draw(Graphic g) in such class.","stock, portfolio, bonds, record .","purchase price: purchase price is used to expressed the value when we bought the stock, it is just use to save the point price that we purchased the price,  so it should not define as class.dividend: it is a result of the calculating a stock's total return, it is the value which calculated from the stock, not need to define as a class.",portfolio,short-term gains and long-term gains because they do not clear to make sense that when is short-term  and when is long-term.,"portfolio  should be the main class, stock are subclass of portfolio.bonds, record are subclass of stock.advantages: bonds, record are subclass of stock will make the class structure more clear to display the need of the project.disadvantages: make the whole stock structure complecated.",responsibilities:calculate the total earningscollaborator:stockresponsibilities:calculate the bondscollaborator:bonds,"class Exam2     def method_missing(meth, *args)         puts #{meth} is not defined.         Exam2.class_eval do            define_method #{meth} do               puts Hello from #{meth}            end         end    endend",Horse::eat() method 1 overrides the Animal::eat() method 0.Horse::eat(String s) method 2 overloads method 1 and method 0.,"Horse eating hay Because a is an instance of Animal and Animal define  eat() method. But in the Horse class it has been overridden, so when we assignAnimal a = new Horse();It will call the eat() method in Horse class.",Yes. Use the Singleton pattern.,OE,ABCO,ADO,ABCDEO,Strategy Pattern,Advantages of Strategy Pattern: Hierarchies of Strategy classes can be used to define a family of algorithms or behaviors for contexts to reuse.Disadvantage :objects will be created to host each algorithm and also the application must know all the strategies before hand to be able to make the right choice for algorithm for the objects."Chen, Ling","The sorting problem is to sort different kinds of arrays in place. We can factor out the differences in these two routines so we can use a single sort routine by moving the comparison function into another class, which is called Comparator. But we have a problem that the compiler cannot determine which method to call. The reason is that it looks at the 2 parameters of compare, which are declared as Objects. But there is not Compare method that takes Objects as parameters. So the compiler reports an error. (i.e., the data type is declared as an object and there is no compare class for object data type)","It depends on different cases. From a formula that holds, you can always get another one that holds by strengthening the precondition or weakening the postcondition.It is possible to give a precondition strong enough that the program is correct regardless of what it does.( i.e. x != x (false)); Similarly, we can make things easy for the program by weakening the postcondition as much as possible, i.e., x == x (true).	      .",active record,Principle of least astonishment,Yo-yo effect,Liskov Substitution Principle,It voilates the polymorphism rule.,"We have to write code for each subtype of Shape in the method . If there are more than 10 subtypes,  the code would look nasty. And when we want to add a new subtype, like triangle, we have to rewrite the code in the function to add the logic to deal with the new subtype. It is very inconvenient.","1) Create a function called createShape in the basic type Shape, make this function abstract, and each subtype implement createShape().   2) The header could be:public abstract Shape createShape(double x, double y, double area)","For each system-defined class, we can create a wrapper class. For example, CircleShape for Circle and RectangleShape for Rectangle. Then we still can create an abstract functions and implement it in different wrapper classes.","portfolio, stock, bond, record","1) short term or long term, can be expressed as enum. 2) gain or loss, can be expressed as a double type.",portfolio owns stocks and bonds.portfolio is the whole and stocks and bonds are the parts.,"1) record representing a key abstraction; 2) All the different senses in which term is used: record, gain, and loss. 3)record is the key abstraction.","1) bonds can be subclasses of stocks. 2) Yes, it makes sense to define a subclass relationship here.3) The advantages are bonds can inherit purchase price, current price, and gain(or loss). The disadvantage is ?instead of dividends, bonds pay interests?.",two responsibilities:1) buyStock2) sellStockthe collaborator:record,"class Exam2    def method_missing(meth, *args, &block)        puts #{meth} is not defined        self.class.class_eval do         	  define_method(meth) do        			      puts Hello from #{meth}      		  end        end        puts Hello from #{meth}    endend",method 1 overrides method eat() in Class Animal;method 2 overloads method eat() in Class Animal,"1) Output: Horse eating hay. 2) In summary, the compiler decides which overloaded method to call by looking at the declared type of a) the object being sent the message and b) the declared types of the arguments to the method call.The particular version of the overloaded method is chosen at runtime by dynamic method invocation using the actual type of the object being sent the message.The actual classes of the arguments to the method call do not play a role.This is very different from a language like CLOS, which uses the actual types of the arguments to decide which method to execute.","Yes. it is possible. Using the final keyword. It prevents the function from being overriden (i.e., public final void eat() and public final void eat(String s))",EO,"X+merge(L(A), L(B), L(C), ABC)= X+merge(AO, BO, CO, ABC)=XABCO","Z+merge(L(D), L(A), DA)= Z+merge(DO, AO, DA)=ZDAO","Q+merge(L(X), L(Y), L(Z), XYZ)= Q+merge(XABCO, YDBEO, ZDAO, XYZ)=QXYZDABCEO","Strategy pattern. It is a behavior design. It define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy pattern lets the algorithm vary independently from the clients that use it. It captures the abstraction in an interface, bury implementation details in derived classes.","Advantages of Strategy Pattern:1) Hierarchies of Strategy classes can be used to define a family of algorithms or behaviors for contexts to reuse. 2) Encapsulating the algorithm in separate Strategy classes lets you vary the algorithm independently of its context. 3) The Strategy pattern offers an alternative to conditional statements for selecting desired behavior. When different behaviors are Encapsulating different behaviours in different Strategy classes eliminates the need for conditional statements. 4)  Should you ever want to add, remove, or change any of the behaviours, it is a much simpler task, since each one is its own class. Each such behaviour or algorithm encapsulated into its own class is called a Strategy.Disadvantage of Strategy pattern:1) A client must understand how Strategies differ to be able to select the right strategy. If possible, the context may be albe to this for you.2) Strategy pattern increases the number of objects in an application.""Ramachandran TA, Lakshmi",,,,,,,,,,,,,,,,,,,,,,,,,,"Shanbhogue, Sanjay","Since there are multiple sort methods which essentially do the same thing on different types of data, it would be more meaningful to use the actual type of arguments to decide which method to call. Even if the variable defined if of type Object, the actual class is either String or Integer. Hence if the argument's actual type is used, the appropriate method can be directly invoked. Hence it would simplify the sorting problem.",(a) Strong preconditions will help achieve correctness. x!=x (false) is a precondition which is strong enough that the program is correct regardless of what it does.(b) Postconditions that are as weak as possible help achieve correctness. x == x (true) is a postcondition that makes it easy for the program since the postcondition is as weak as possible.,Scaffolding,The principle of least astonishment.,Could be due to polymorphism and/or method overriding.,The Liskov Substitution Principle.,"The method makeOneShapeFromAnother has been defined as static, which means it is a class method. So we need not instantiate the method (create an object of the class) to access this method.Also, there are a lot of conditionals to check the type. Instead each functionality should have a separate method. The current method does more work than the name suggests.","It is bad to violate this rule because you do not need an object of the class to access this method. It is more or less a non-OO approach. As far as the conditionals are concerned, it is inelegant to write code in this fashion. You can instead define separate methods for each functionality.","First, copy the body of each conditional statement and put it in a separate method. Then invoke that method from this method. Once everything is tested and working, completely remove the old statements and retain only the calls to the new methods and the new method definitions.The headers for the new methods are:public void CircleShape() {//calculate radius and define outshape}public void RectangleShape() {//calculate width and define outshape}public void CylinderShape() {//calculate radius, height and define outshape}",No because that would introduce unnecessary complexity. By using the system-defined classes we can maintain brevity.,"portfolio, gain, interest, dividend, total return, record",short term - the gain may be short term. it is the gain that is the key abstraction and not whether it is short term or not. tax - tax is not a key abstraction since it is due on gain which is another key abstraction. and the calculation is done by a record.,gain has an aggregation relationship with short term and long term.stock has an aggregation relationship with purchase price and current price.,gain is the key abstraction used ambiguously. the different senses in which it is used are:short term gainlong term gainnegative gain (loss)the gain used as key abstraction depends on how long the position was held.,"stock can be a subclass of a portfolio.since there are a lot of stocks in each portfolio it makes sense to use subclassing. this helps in reuse of code that is applicable to both portfolio and stock since they have some common features that identify them.however, a disadvantage is that a stock need not inherit all the features of a portfolio, but it must when it is a subclass.",responsibilties:  know_stock_postions                 collaborator is stock know_purchase_price_of_stock    know_current_price_of_stock calculate_gain                           collaborator is gain       caluclate_total_earnings,"class Exam2  def method_missing(meth, *args)    puts #{meth} is not defined    eval %{def #{meth}                puts Hello from #{meth}              end}  endende=Exam2.newe.sayHelloe.sayHello",method 1 overrides method 0.method 2 overloads method 1.,"The output is Horse eating hay.Since the declared type of the object a is Animal, it looks for a method with signature closest to that of eat when a.eat is called. It finds the eat method in class Animal. However with dynamic method invocation, it finds the overridden method in the subclass Horse and calls that method.","Yes. Both the methods can be made class methods and declared as final so that they cannot be modified ever again/overridden. This can be done as follows:     public static final void eat() { //method 1        	System.out.println(Horse eating hay );     }     public static final void eat(String s) { //method 2       	System.out.println(Horse eating  + s);     }","E+merge(O,O) = EO","X+merge(AO,BO,CO,ABC) = XABCO","Z+merge(DO,AO,DA) = ZDAO","Q+merge(XABCO,YDBEO,ZDAO,XYZ) = QXYZDABCEO","The Adapter pattern is being used. This pattern is used to implement delegation. An adapter allows classes to work together that normally could not because of incompatible interfaces.It ?wraps? its own interface around the interface of a pre-existing class. It may also translate data formats from the caller to a form needed by the callee.Here, the class PerformOperation stores a reference to the type of the interface Iprint so that it can use the methods that are in that interface from the classes that have implemented this interface.","The main advantage of the Adapter pattern is that it allows the Client to use the Adaptee with minimal modifications to either class. The only new code that is needed appears in the Adapter class.A disadvantage of using the Adapter pattern is that you have introduced yet another class into the design and therefore made it slightly more complex. Furthermore, there is now one more level of indirection in getting data to the front end from the back end; namely, the front end needs to ask the adapter class forthe data, which then asks the actual back end for some data and converts that data into the form desired by the front end.""Tungatkar TA, Gaurav",,,,,,,,,,,,,,,,,,,,,,,,,,